/// Strategy model representing trading strategies
class Strategy {
  final int id;
  final String name;
  final String? description;
  final String type;
  final String status;
  final String? exchange;
  final String? symbol;
  final String? normalizedSymbol; // Auto-generated by backend
  final String marketType; // Auto-generated: 'spot', 'perpetual', 'futures'
  final Map<String, dynamic>? parameters;
  final String? errorMessage;
  final DateTime? lastExecutionTime;
  final DateTime createdAt;
  final DateTime updatedAt;

  Strategy({
    required this.id,
    required this.name,
    this.description,
    required this.type,
    required this.status,
    this.exchange,
    this.symbol,
    this.normalizedSymbol,
    this.marketType = 'spot',
    this.parameters,
    this.errorMessage,
    this.lastExecutionTime,
    required this.createdAt,
    required this.updatedAt,
    this.performance,
  });

  factory Strategy.fromJson(Map<String, dynamic> json) {
    return Strategy(
      id: _parseInt(json['id']),
      name: json['name'] as String,
      description: json['description'] as String?,
      type: json['type'] as String,
      status: json['status'] as String,
      exchange: json['exchange'] as String?,
      symbol: json['symbol'] as String?,
      normalizedSymbol: json['normalizedSymbol'] as String?,
      marketType: json['marketType'] as String? ?? 'spot',
      parameters: json['parameters'] as Map<String, dynamic>?,
      errorMessage: json['errorMessage'] as String?,
      lastExecutionTime: json['lastExecutionTime'] != null
          ? DateTime.parse(json['lastExecutionTime'] as String)
          : null,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      performance: json['performance'] != null
          ? StrategyPerformance.fromJson(json['performance'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'type': type,
      'status': status,
      'exchange': exchange,
      'symbol': symbol,
      'parameters': parameters,
      'errorMessage': errorMessage,
      'lastExecutionTime': lastExecutionTime?.toIso8601String(),
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
      // performance is typically read-only from backend, but good to have symmetry
    };
  }

  bool get isActive => status == 'active';
  bool get isStopped => status == 'stopped';
  bool get isPaused => status == 'paused';
  bool get isError => status == 'error';

  final StrategyPerformance? performance;
}

class StrategyPerformance {
  final double totalPnL;
  final double roi;
  final double winRate;
  final double maxDrawdown;
  final int totalOrders;
  final int winningTrades;
  final int losingTrades;
  final int longOrdersFilledCount;
  final int shortOrdersFilledCount;

  StrategyPerformance({
    required this.totalPnL,
    required this.roi,
    required this.winRate,
    required this.maxDrawdown,
    required this.totalOrders,
    required this.winningTrades,
    required this.losingTrades,
    required this.longOrdersFilledCount,
    required this.shortOrdersFilledCount,
  });

  factory StrategyPerformance.fromJson(Map<String, dynamic> json) {
    return StrategyPerformance(
      totalPnL: _parseDouble(json['totalPnL']),
      roi: _parseDouble(json['roi']),
      winRate: _parseDouble(json['winRate']),
      maxDrawdown: _parseDouble(json['maxDrawdown']),
      totalOrders: _parseInt(json['totalOrders']),
      winningTrades: _parseInt(json['winningTrades']),
      losingTrades: _parseInt(json['losingTrades']),
      longOrdersFilledCount: _parseInt(json['longOrdersFilledCount']),
      shortOrdersFilledCount: _parseInt(json['shortOrdersFilledCount']),
    );
  }
}

/// Strategy PnL data
class StrategyPnL {
  final int strategyId;
  final String strategyName;
  final double totalPnl;
  final double realizedPnl;
  final double unrealizedPnl;
  final int totalOrders;
  final int filledOrders;

  StrategyPnL({
    required this.strategyId,
    required this.strategyName,
    required this.totalPnl,
    required this.realizedPnl,
    required this.unrealizedPnl,
    required this.totalOrders,
    required this.filledOrders,
  });

  factory StrategyPnL.fromJson(Map<String, dynamic> json) {
    return StrategyPnL(
      strategyId: _parseInt(json['strategyId']),
      strategyName: json['strategyName'] as String? ?? '',
      totalPnl: _parseDouble(json['pnl']),
      realizedPnl: _parseDouble(json['realizedPnl']),
      unrealizedPnl: _parseDouble(json['unrealizedPnl']),
      totalOrders: _parseInt(json['totalOrders']),
      filledOrders: _parseInt(json['filledOrders']),
    );
  }

  bool get isProfitable => totalPnl > 0;
  bool get isLoss => totalPnl < 0;
}

double _parseDouble(dynamic value, {double fallback = 0.0}) {
  if (value == null) {
    return fallback;
  }
  if (value is num) {
    return value.toDouble();
  }
  if (value is String) {
    return double.tryParse(value) ?? fallback;
  }
  return fallback;
}

int _parseInt(dynamic value, {int fallback = 0}) {
  if (value == null) {
    return fallback;
  }
  if (value is int) {
    return value;
  }
  if (value is num) {
    return value.toInt();
  }
  if (value is String) {
    final intValue = int.tryParse(value);
    if (intValue != null) {
      return intValue;
    }
    final doubleValue = double.tryParse(value);
    if (doubleValue != null) {
      return doubleValue.toInt();
    }
  }
  return fallback;
}
