import { EventEmitter } from 'events';

import { Decimal } from 'decimal.js';

import {
  DataUpdate,
  IStrategy,
  StrategyStateSnapshot,
  StrategyRecoveryContext,
  ILogger,
} from '../interfaces';
import {
  StrategyParameters,
  StrategyConfig,
  StrategyRuntimeContext,
  StrategyResult,
  Order,
  Position,
  Balance,
  AccountInfo,
  Kline,
  Ticker,
  OrderBook,
  Trade,
  OrderSide,
  SignalType,
  InitialDataResult,
  InitialDataConfig,
  SubscriptionConfig,
} from '../types';
import { ConsoleLogger } from './ConsoleLogger';

export abstract class BaseStrategy<
    TParams extends StrategyParameters = StrategyParameters,
  >
  extends EventEmitter
  implements IStrategy<TParams>
{
  protected _parameters: TParams;
  protected _context: StrategyRuntimeContext;
  private _strategyType: string;
  protected _isInitialized = false;
  protected _exchangeName: string;
  protected _symbol: string;
  protected _quote: string;
  protected _base: string;
  protected _settlement?: string;

  // üÜï State Management Properties
  protected _strategyId?: number;
  protected _strategyName?: string; // User-defined name from database
  protected _currentPosition = new Decimal(0);
  protected _averagePrice?: Decimal;
  protected _lastSignal?: string;
  protected _lastSignalTime?: Date;
  protected _stateVersion = '1.0.0'; // Override in subclasses if needed
  protected _logger: ILogger;

  // üÜï ËÆ¢ÂçïÂ∫èÂàóÂè∑ÔºàÁî®‰∫éÁîüÊàêÂîØ‰∏Ä clientOrderIdÔºâ
  protected orderSequence: number = 0;

  public get strategyType(): string {
    return this._strategyType;
  }

  constructor(config: StrategyConfig<TParams>) {
    super();

    // Extract all fields from config
    const {
      type,
      parameters,
      symbol,
      exchange,
      strategyId,
      strategyName,
      logger,
      subscription,
      initialDataConfig,
      loadedInitialData,
    } = config;

    this._strategyType = type;
    this._parameters = parameters;
    this._context = {
      symbol,
      exchange,
      strategyId,
      strategyName,
      logger,
      subscription,
      initialDataConfig,
      loadedInitialData,
    };

    this._logger = logger || new ConsoleLogger();
    this._strategyId = strategyId;
    this._strategyName = strategyName;
    this._exchangeName = Array.isArray(exchange) ? exchange[0] : exchange;
    this._symbol = symbol;

    const parts = symbol.split(/[/:]/).filter(Boolean);
    this._quote = parts[0];
    this._base = parts[1];
    this._settlement = parts.length > 2 ? parts[2] : undefined;

    // indicate that strategy is initialized, is ready to use. you need to override this method in your strategy, and set this._initialized to true, and emit 'initialized' event.
    this.onInitialize();
  }

  public get config(): StrategyConfig<TParams> {
    return {
      type: this._strategyType,
      parameters: { ...this._parameters },
      ...this._context,
    };
  }

  public get parameters(): TParams {
    return { ...this._parameters };
  }

  public get context(): StrategyRuntimeContext {
    return { ...this._context };
  }

  /**
   * üÜï ÁîüÊàêÂîØ‰∏ÄÁöÑ clientOrderId
   * OKXË¶ÅÊ±Ç: Â≠óÊØçÊï∞Â≠óÂ≠óÁ¨¶, ÊúÄÂ§ßÈïøÂ∫¶32Â≠óÁ¨¶
   */
  protected generateClientOrderId(type: SignalType): string {
    this.orderSequence++;
    // ‰ΩøÁî®Êõ¥Áü≠ÁöÑÊó∂Èó¥Êà≥ÔºàÂéªÊéâÊØ´ÁßíÁöÑÂêé3‰ΩçÔºâÂíåÂâçÁºÄ
    const shortTimestamp = Math.floor(Date.now() / 1000); // Unix timestamp in seconds
    const strategyId = this.getStrategyId();
    // ‰∏ªËÆ¢ÂçïÊ†ºÂºè: E{strategyId}D{sequence}D{timestamp} , Ê≠¢ÁõàËÆ¢Âçï: T{strategyId}D{sequence}D{timestamp}
    const typePrefix = type === SignalType.Entry ? 'E' : 'T';
    return `${typePrefix}${strategyId}D${this.orderSequence}D${shortTimestamp}`;
  }

  public abstract analyze(marketData: DataUpdate): Promise<StrategyResult>;

  /**
   * Called when an order is created from this strategy's signal
   * Override this method to track orders generated by the strategy
   */
  public async onOrderCreated(order: Order): Promise<void> {
    this.emit('orderCreated', order);
    this._logger.debug(
      `[${this.strategyType}:${this._strategyId}] Order created: ${order.clientOrderId} (${order.side} ${order.quantity.toString()} @ ${order.price?.toString() || 'MARKET'})`,
    );
    // Subclasses can override this to track their orders
  }

  public async onOrderFilled(order: Order): Promise<void> {
    this.emit('orderFilled', order);
    // Default implementation: update position
    if (order.symbol === this._symbol && order.exchange === this._exchangeName) {
      const filledQuantity = order.executedQuantity || new Decimal(0);
      if (order.side === OrderSide.BUY) {
        this._currentPosition = this._currentPosition.plus(filledQuantity);
      } else if (order.side === OrderSide.SELL) {
        this._currentPosition = this._currentPosition.minus(filledQuantity);
      }
      this._averagePrice = order.averagePrice;
      this._logger.debug(
        `[${this.strategyType}:${this._strategyId}] Position updated: ${this._currentPosition.toString()} @ ${this._averagePrice?.toString()}`,
      );
    }
  }

  public async onPositionUpdate(position: Position): Promise<void> {
    this.emit('positionUpdate', position);
    if (
      position.symbol === this._symbol &&
      (position as any).exchange === this._exchangeName
    ) {
      this._currentPosition = position.quantity;
      this._averagePrice = position.avgPrice;
      this._logger.debug(
        `[${this.strategyType}:${this._strategyId}] External position update: ${this._currentPosition.toString()} @ ${this._averagePrice?.toString()}`,
      );
    }
  }

  public async onBalanceUpdate(balance: Balance): Promise<void> {
    this.emit('balanceUpdate', balance);
    // Default implementation: log balance changes
    this._logger.debug(
      `[${this.strategyType}:${this._strategyId}] Balance update for ${balance.asset}: Free ${balance.free.toString()}, Locked ${balance.locked.toString()}`,
    );
  }

  public async onAccountUpdate(accountInfo: AccountInfo): Promise<void> {
    this.emit('accountUpdate', accountInfo);
    // Default implementation: log account info changes
    this._logger.debug(
      `[${this.strategyType}:${this._strategyId}] Account update: Can trade: ${accountInfo.canTrade}`,
    );
  }

  public async onKlineUpdate(kline: Kline): Promise<void> {
    this.emit('klineUpdate', kline);
    // Default implementation: no-op
  }

  public async onTickerUpdate(ticker: Ticker): Promise<void> {
    this.emit('tickerUpdate', ticker);
    // Default implementation: no-op
  }

  public async onOrderBookUpdate(orderBook: OrderBook): Promise<void> {
    this.emit('orderBookUpdate', orderBook);
    // Default implementation: no-op
  }

  public async onTradeUpdate(trade: Trade): Promise<void> {
    this.emit('tradeUpdate', trade);
    // Default implementation: no-op
  }

  protected async onInitialize(): Promise<void> {
    // Override in derived classes for custom initialization
    this._isInitialized = true;
    this.emit('initialized', this.strategyType);
  }

  protected async onCleanup(): Promise<void> {
    // Override in derived classes for custom cleanup
  }

  // Utility methods for derived strategies
  protected getParameter<K extends keyof TParams>(key: K): TParams[K] {
    return this._parameters[key];
  }

  protected setParameter<K extends keyof TParams>(key: K, value: TParams[K]): void {
    this._parameters[key] = value;
  }

  // üÜï State Management Methods Implementation

  /**
   * Save current strategy state - override in derived classes for custom state
   */
  public async saveState(): Promise<StrategyStateSnapshot> {
    const state: StrategyStateSnapshot = {
      strategyId: this._strategyId,
      strategyType: this.strategyType,
      stateVersion: this._stateVersion,
      timestamp: new Date(),
      internalState: {},
      indicatorData: {},
      lastSignal: this._lastSignal,
      signalTime: this._lastSignalTime,
      currentPosition: this._currentPosition.toString(),
      averagePrice: this._averagePrice?.toString(),
    };
    // Derived classes should populate internalState and indicatorData
    return state;
  }

  /**
   * Load strategy state for recovery - override in derived classes for custom state
   */
  public async loadState(
    snapshot: StrategyStateSnapshot,
  ): Promise<StrategyRecoveryContext> {
    this._strategyId = snapshot.strategyId;
    this._lastSignal = snapshot.lastSignal;
    this._lastSignalTime = snapshot.signalTime;
    this._currentPosition = new Decimal(snapshot.currentPosition || 0);
    this._averagePrice = snapshot.averagePrice
      ? new Decimal(snapshot.averagePrice)
      : undefined;
    this._stateVersion = snapshot.stateVersion || '1.0.0';

    // Derived classes should use snapshot.internalState and snapshot.indicatorData
    return {
      recovered: true,
      message: `State loaded for ${this.strategyType}:${this._strategyId} (version ${this._stateVersion})`,
      metrics: {
        recoveryTime: new Date(),
        lastSignal: this._lastSignal,
        currentPosition: this._currentPosition,
      },
    };
  }

  /**
   * Process initial data loaded by TradingEngine
   * This is called after initial data (klines, positions, orders, etc.) is loaded
   * and before real-time subscriptions begin.
   *
   * Default implementation does nothing - derived classes should override if they need
   * to process initial data (e.g., populate buffers, set initial positions, etc.)
   *
   * @param initialData - The loaded initial data containing klines, positions, orders, etc.
   */
  public processInitialData(initialData: InitialDataResult): void {
    // Default implementation: log and do nothing
    this._logger.debug(
      `[${this.strategyType}] processInitialData called, method not overridden in derived class:`,
    );
    this._logger.debug(JSON.stringify(initialData, null, 2));
    // Derived classes should override this to process initial data
    // Example: Load klines into buffers, set initial positions, etc.
  }

  /**
   * üÜï Get Initial Data Configuration
   * TradingEngine calls this method to determine what initial data to load
   * before the strategy starts.
   *
   * Default implementation returns the config from context.
   * Derived classes can override this to provide dynamic configuration
   * based on strategy parameters.
   *
   * @returns InitialDataConfig - Configuration for initial data loading
   */
  public getInitialDataConfig(): InitialDataConfig {
    return this._context.initialDataConfig || {};
  }

  /**
   * üÜï Get Subscription Configuration
   * TradingEngine calls this method to determine what real-time data
   * subscriptions to set up for this strategy.
   *
   * Default implementation returns the config from context.
   * Derived classes can override this to provide dynamic configuration
   * based on strategy parameters.
   *
   * @returns SubscriptionConfig - Configuration for real-time subscriptions
   */
  public getSubscriptionConfig(): SubscriptionConfig {
    return this._context.subscription || {};
  }

  /**
   * Get current health status of the strategy
   */
  public getHealthStatus() {
    return {
      status: this._isInitialized ? ('healthy' as const) : ('initializing' as const),
      message: this._isInitialized ? 'Strategy is running' : 'Strategy is initializing',
      timestamp: new Date(),
      lastSignal: this._lastSignal,
      currentPosition: this._currentPosition,
    };
  }

  public getStrategyId(): number | undefined {
    return this._strategyId;
  }

  public getStrategyName(): string | undefined {
    return this._strategyName;
  }

  public getSymbol(): string {
    return this._symbol;
  }

  public getExchangeName(): string {
    return this._exchangeName;
  }

  public getQuoteAsset(): string {
    return this._quote;
  }

  public getBaseAsset(): string {
    return this._base;
  }

  public getSettlementAsset(): string | undefined {
    return this._settlement;
  }

  public isInitialized(): boolean {
    return this._isInitialized;
  }

  public getLogger(): ILogger {
    return this._logger;
  }

  protected getLastSignal(): string | undefined {
    return this._lastSignal;
  }

  protected setLastSignal(signal: string): void {
    this._lastSignal = signal;
    this._lastSignalTime = new Date();
  }

  protected getCurrentPosition(): Decimal {
    return this._currentPosition;
  }

  protected getAveragePrice(): Decimal | undefined {
    return this._averagePrice;
  }
}
