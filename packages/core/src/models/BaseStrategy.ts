import { EventEmitter } from 'events';

import { Decimal } from 'decimal.js';

import { DataUpdate, IStrategy, ILogger } from '../interfaces';
import {
  StrategyParameters,
  StrategyConfig,
  StrategyRuntimeContext,
  StrategyAnalyzeResult,
  Order,
  Position,
  Balance,
  AccountInfo,
  Kline,
  Ticker,
  OrderBook,
  Trade,
  OrderSide,
  SignalType,
  InitialDataResult,
  InitialDataConfig,
  SubscriptionConfig,
  StrategyPerformance,
  createEmptyPerformance,
} from '../types';
import { ConsoleLogger } from './ConsoleLogger';
import { PerformanceTracker } from '../utils/PerformanceTracker';

export abstract class BaseStrategy<
    TParams extends StrategyParameters = StrategyParameters,
  >
  extends EventEmitter
  implements IStrategy<TParams>
{
  protected _parameters: TParams;
  protected _context: StrategyRuntimeContext;
  private _strategyType: string;
  protected _isInitialized = false;
  protected _exchangeName: string;
  protected _symbol: string;
  protected _quote: string;
  protected _base: string;
  protected _settlement?: string;

  // ğŸ†• State Management Properties
  protected _strategyId?: number;
  protected _strategyName?: string; // User-defined name from database
  protected _currentPosition = new Decimal(0);
  protected _averagePrice?: Decimal;
  protected _lastSignal?: string;
  protected _lastSignalTime?: Date;
  protected _stateVersion = '1.0.0'; // Override in subclasses if needed
  protected _logger: ILogger;

  // ğŸ†• è®¢å•åºåˆ—å·ï¼ˆç”¨äºç”Ÿæˆå”¯ä¸€ clientOrderIdï¼‰
  protected orderSequence: number = 0;

  public get strategyType(): string {
    return this._strategyType;
  }

  constructor(config: StrategyConfig<TParams>) {
    super();

    // Extract all fields from config
    const {
      type,
      parameters,
      symbol,
      exchange,
      strategyId,
      strategyName,
      logger,
      subscription,
      initialDataConfig,
      loadedInitialData,
      performance,
    } = config;

    this._strategyType = type;
    this._parameters = parameters;
    this._context = {
      symbol,
      exchange,
      strategyId,
      strategyName,
      logger,
      subscription,
      initialDataConfig,
      loadedInitialData,
      performance:
        performance ||
        createEmptyPerformance(
          symbol,
          Array.isArray(exchange) ? exchange[0] : exchange,
          strategyId,
          strategyName,
        ),
    };

    this._logger = logger || new ConsoleLogger();
    this._strategyId = strategyId;
    this._strategyName = strategyName;
    this._exchangeName = Array.isArray(exchange) ? exchange[0] : exchange;
    this._symbol = symbol;

    const parts = symbol.split(/[/:]/).filter(Boolean);
    this._quote = parts[0];
    this._base = parts[1];
    this._settlement = parts.length > 2 ? parts[2] : undefined;

    // indicate that strategy is initialized, is ready to use. you need to override this method in your strategy, and set this._initialized to true, and emit 'initialized' event.
    this.onInitialize();
  }

  public get config(): StrategyConfig<TParams> {
    return {
      type: this._strategyType,
      parameters: { ...this._parameters },
      ...this._context,
    };
  }

  public get parameters(): TParams {
    return { ...this._parameters };
  }

  public get context(): StrategyRuntimeContext {
    return { ...this._context };
  }

  /**
   * ğŸ†• ç”Ÿæˆå”¯ä¸€çš„ clientOrderId
   * OKXè¦æ±‚: å­—æ¯æ•°å­—å­—ç¬¦, æœ€å¤§é•¿åº¦32å­—ç¬¦
   */
  protected generateClientOrderId(type: SignalType): string {
    this.orderSequence++;
    // ä½¿ç”¨æ›´çŸ­çš„æ—¶é—´æˆ³ï¼ˆå»æ‰æ¯«ç§’çš„å3ä½ï¼‰å’Œå‰ç¼€
    const shortTimestamp = Math.floor(Date.now() / 1000); // Unix timestamp in seconds
    const strategyId = this.getStrategyId();
    // ä¸»è®¢å•æ ¼å¼: E{strategyId}D{sequence}D{timestamp} , æ­¢ç›ˆè®¢å•: T{strategyId}D{sequence}D{timestamp}
    const typePrefix = type === SignalType.Entry ? 'E' : 'T';
    return `${typePrefix}${strategyId}D${this.orderSequence}D${shortTimestamp}`;
  }

  /**
   * Analyze market/account data and return trading signals
   *
   * Subclasses must implement this method to define their trading logic.
   * Can return a single result or an array of results for multiple
   * simultaneous actions (e.g., place TP order + place next entry order).
   *
   * @param marketData - Market data (ticker, orderbook, klines) or account data (orders, positions)
   * @returns Single result or array of results
   */
  public abstract analyze(marketData: DataUpdate): Promise<StrategyAnalyzeResult>;

  /**
   * Called when an order is created from this strategy's signal
   * Override this method to track orders generated by the strategy
   */
  public async onOrderCreated(order: Order): Promise<void> {
    this.emit('orderCreated', order);
    this._logger.debug(
      `[${this.strategyType}:${this._strategyId}] Order created: ${order.clientOrderId} (${order.side} ${order.quantity.toString()} @ ${order.price?.toString() || 'MARKET'})`,
    );
  }

  public async onOrderFilled(order: Order): Promise<void> {
    this.emit('orderFilled', order);

    // Only update performance counters (counts/status)
    // Volume/Fees/Position updates are handled in onTradeExecuted via partial fills
    if (order.symbol === this._symbol && order.exchange === this._exchangeName) {
      this._context.performance = PerformanceTracker.updateWithOrder(
        this._context.performance,
        order,
      );
    }
  }

  /**
   * ğŸ†• Called when a trade execution (fill) occurs
   * Handles both partial fills and final fills
   */
  public async onTradeExecuted(trade: Trade): Promise<void> {
    this.emit('tradeExecuted', trade);

    if (trade.symbol === this._symbol && trade.exchange === this._exchangeName) {
      // Update internal position state incrementally
      const quantity = trade.quantity;
      if (String(trade.side).toLowerCase() === 'buy') {
        this._currentPosition = this._currentPosition.plus(quantity);
      } else if (String(trade.side).toLowerCase() === 'sell') {
        this._currentPosition = this._currentPosition.minus(quantity);
      }

      // Update average price if available
      this._averagePrice = trade.price;

      this._logger.debug(
        `[${this.strategyType}:${this._strategyId}] Trade executed: ${trade.side} ${quantity} @ ${trade.price}`,
      );

      // Update performance metrics (Volume, Fees, PnL)
      this._context.performance = PerformanceTracker.updateWithTrade(
        this._context.performance,
        trade,
      );
    }
  }

  public async onPositionUpdate(position: Position): Promise<void> {
    this.emit('positionUpdate', position);
    if (
      position.symbol === this._symbol &&
      (position as any).exchange === this._exchangeName
    ) {
      this._currentPosition = position.quantity;
      this._averagePrice = position.avgPrice;
      this._logger.debug(
        `[${this.strategyType}:${this._strategyId}] External position update: ${this._currentPosition.toString()} @ ${this._averagePrice?.toString()}`,
      );

      // ğŸ†• Update performance metrics
      this._context.performance = PerformanceTracker.updateWithPosition(
        this._context.performance,
        position,
      );
    }
  }

  public async onBalanceUpdate(balance: Balance): Promise<void> {
    this.emit('balanceUpdate', balance);
    // Default implementation: log balance changes
    this._logger.debug(
      `[${this.strategyType}:${this._strategyId}] Balance update for ${balance.asset}: Free ${balance.free.toString()}, Locked ${balance.locked.toString()}`,
    );
  }

  public async onAccountUpdate(accountInfo: AccountInfo): Promise<void> {
    this.emit('accountUpdate', accountInfo);
    // Default implementation: log account info changes
    this._logger.debug(
      `[${this.strategyType}:${this._strategyId}] Account update: Can trade: ${accountInfo.canTrade}`,
    );
  }

  public async onKlineUpdate(kline: Kline): Promise<void> {
    this.emit('klineUpdate', kline);
    // Default implementation: no-op
  }

  public async onTickerUpdate(ticker: Ticker): Promise<void> {
    this.emit('tickerUpdate', ticker);
    // Default implementation: no-op
  }

  public async onOrderBookUpdate(orderBook: OrderBook): Promise<void> {
    this.emit('orderBookUpdate', orderBook);
    // Default implementation: no-op
  }

  public async onTradeUpdate(trade: Trade): Promise<void> {
    this.emit('tradeUpdate', trade);
    // Default implementation: no-op
  }

  protected async onInitialize(): Promise<void> {
    // Override in derived classes for custom initialization
    this._isInitialized = true;
    this.emit('initialized', this.strategyType);
  }

  protected async onCleanup(): Promise<void> {
    // Override in derived classes for custom cleanup
  }

  // Utility methods for derived strategies
  protected getParameter<K extends keyof TParams>(key: K): TParams[K] {
    return this._parameters[key];
  }

  protected setParameter<K extends keyof TParams>(key: K, value: TParams[K]): void {
    this._parameters[key] = value;
  }

  // ğŸ†• State Management Methods Implementation

  /**
   * Save current strategy state - override in derived classes for custom state
   */

  /**
   * Process initial data loaded by TradingEngine
   * This is called after initial data (klines, positions, orders, etc.) is loaded
   * and before real-time subscriptions begin.
   *
   * Default implementation does nothing - derived classes should override if they need
   * to process initial data (e.g., populate buffers, set initial positions, etc.)
   *
   * @param initialData - The loaded initial data containing klines, positions, orders, etc.
   */
  public async processInitialData(
    initialData: InitialDataResult,
  ): Promise<StrategyAnalyzeResult> {
    // Default implementation: log and do nothing
    this._logger.debug(
      `[${this.strategyType}] processInitialData called, method not overridden in derived class:`,
    );
    this._logger.debug(JSON.stringify(initialData, null, 2));
    // Derived classes should override this to process initial data
    // Example: Load klines into buffers, set initial positions, etc.
    return { action: 'hold' };
  }

  /**
   * ğŸ†• Get Initial Data Configuration
   * TradingEngine calls this method to determine what initial data to load
   * before the strategy starts.
   *
   * Default implementation returns the config from context.
   * Derived classes can override this to provide dynamic configuration
   * based on strategy parameters.
   *
   * @returns InitialDataConfig - Configuration for initial data loading
   */
  public getInitialDataConfig(): InitialDataConfig {
    return this._context.initialDataConfig || {};
  }

  /**
   * ğŸ†• Get Subscription Configuration
   * TradingEngine calls this method to determine what real-time data
   * subscriptions to set up for this strategy.
   *
   * Default implementation returns the config from context.
   * Derived classes can override this to provide dynamic configuration
   * based on strategy parameters.
   *
   * @returns SubscriptionConfig - Configuration for real-time subscriptions
   */
  public getSubscriptionConfig(): SubscriptionConfig {
    return this._context.subscription || {};
  }

  /**
   * Get current health status of the strategy
   */
  public getHealthStatus() {
    return {
      status: this._isInitialized ? ('healthy' as const) : ('initializing' as const),
      message: this._isInitialized ? 'Strategy is running' : 'Strategy is initializing',
      timestamp: new Date(),
      lastSignal: this._lastSignal,
      currentPosition: this._currentPosition,
    };
  }

  public getStrategyId(): number | undefined {
    return this._strategyId;
  }

  public getStrategyName(): string | undefined {
    return this._strategyName;
  }

  public getSymbol(): string {
    return this._symbol;
  }

  public getExchangeName(): string {
    return this._exchangeName;
  }

  public getQuoteAsset(): string {
    return this._quote;
  }

  public getBaseAsset(): string {
    return this._base;
  }

  public getSettlementAsset(): string | undefined {
    return this._settlement;
  }

  public isInitialized(): boolean {
    return this._isInitialized;
  }

  public getLogger(): ILogger {
    return this._logger;
  }

  protected getLastSignal(): string | undefined {
    return this._lastSignal;
  }

  protected setLastSignal(signal: string): void {
    this._lastSignal = signal;
    this._lastSignalTime = new Date();
  }

  protected getCurrentPosition(): Decimal {
    return this._currentPosition;
  }

  protected getAveragePrice(): Decimal | undefined {
    return this._averagePrice;
  }

  /**
   * ğŸ†• Get current performance metrics
   */
  public getPerformance(): StrategyPerformance {
    // Update time metrics before returning
    this._context.performance = PerformanceTracker.updateTimeMetrics(
      this._context.performance,
    );
    return this._context.performance;
  }

  /**
   * ğŸ†• Get performance summary for quick display
   */
  public getPerformanceSummary() {
    return PerformanceTracker.getSummary(this._context.performance);
  }
}
