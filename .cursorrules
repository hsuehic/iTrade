# iTrade Project - AI Agent Documentation Rules

## üìÇ Documentation Structure

When creating or modifying documentation files, follow this structure:

### Root Level

- `README.md` - Project overview and main documentation entry point
- Keep root directory clean, avoid creating new documentation files here

### Documentation Directories

#### `/docs/` - Project-level Documentation

Main documentation hub for the entire project.

**Subdirectories:**

- `/docs/guides/` - User guides and tutorials
  - Quick start guides
  - How-to guides
  - Best practices
  - Examples: `PROJECT_QUICK_START.md`, `RUN_COMMANDS.md`, `STRATEGY_MANAGEMENT_GUIDE.md`

- `/docs/development/` - Development process documentation
  - Implementation summaries
  - Improvement logs
  - Migration guides
  - Bug fixes documentation
  - Examples: `CONSOLE_WEB_IMPROVEMENTS.md`, `IMPLEMENTATION_SUMMARY.md`, `IMPROVEMENTS_SUMMARY.md`

- `/docs/api/` - API reference documentation
  - Existing: `API-REFERENCE-MARKET-DATA.md`
  - API specifications
  - Interface documentation

- `/docs/architecture/` - Architecture and design documentation
  - System design documents
  - Architecture decisions (ADR)
  - Technical specifications
  - Existing: `DESIGN-ANALYSIS-MARKET-DATA-API.md`, `trading-engine-analysis.md`

#### Application-Specific Documentation

**Console Application** - `/apps/console/docs/`

- `QUICK_START.md` - Console quick start guide
- Application-specific guides
- Console configuration

**Web Application** - `/apps/web/docs/`

- Web application guides
- API documentation
- Deployment guides

**Mobile Application** - `/apps/mobile/docs/`

- Mobile setup guides
- Platform-specific documentation
- Build instructions

#### Package-Specific Documentation

**Core Package** - `/packages/core/docs/`

- Core functionality documentation
- Examples: `ORDER_SYNC_MECHANISM.md`, `ORDER_SYNC_IMPLEMENTATION.md`
- API reference for core modules

**Data Manager** - `/packages/data-manager/docs/`

- Database schema documentation
- Data migration guides

**Exchange Connectors** - `/packages/exchange-connectors/docs/`

- Exchange integration guides
- Per-exchange documentation

**Other Packages** - `/packages/{package-name}/docs/`

- Package-specific documentation
- Usage examples
- API reference

---

## üìù Documentation Naming Conventions

### File Names

- Use `UPPERCASE_WITH_UNDERSCORES.md` for important top-level docs
- Use `lowercase-with-hyphens.md` for regular documentation
- Use descriptive names: `QUICK_START.md`, `API_REFERENCE.md`

### Bilingual Documentation Naming

**Default Language**: English (no suffix)
**Chinese Version**: Add `_CN` suffix

Examples:

- `README.md` - English (default)
- `README_CN.md` - Chinese version
- `QUICK_START.md` - English
- `QUICK_START_CN.md` - Chinese version
- `API_REFERENCE.md` - English
- `API_REFERENCE_CN.md` - Chinese version

**Rationale**:

- English is the international standard for open-source projects
- Cursor AI and most development tools work best with English
- Makes the project more accessible to global developers

### Document Types and Locations

| Document Type | Location | Example |
|--------------|----------|---------|
| Quick Start Guide | `{app}/docs/QUICK_START.md` | `apps/console/docs/QUICK_START.md` |
| User Guide | `docs/guides/` | `docs/guides/STRATEGY_MANAGEMENT_GUIDE.md` |
| API Reference | `docs/api/` or `{package}/docs/` | `packages/core/docs/API_REFERENCE.md` |
| Implementation Log | `docs/development/` | `docs/development/IMPLEMENTATION_SUMMARY.md` |
| Architecture Doc | `docs/architecture/` | `docs/architecture/SYSTEM_DESIGN.md` |
| Package Feature Doc | `{package}/docs/` | `packages/core/docs/ORDER_SYNC_MECHANISM.md` |
| Troubleshooting | `docs/guides/` | `docs/guides/TROUBLESHOOTING.md` |
| Changelog | `docs/development/` | `docs/development/CHANGELOG.md` |

---

## üéØ When Creating New Documentation

### Step 1: Determine Document Type

Ask yourself:

- Is this a user guide? ‚Üí `docs/guides/`
- Is this implementation/improvement documentation? ‚Üí `docs/development/`
- Is this API reference? ‚Üí `docs/api/` or `{package}/docs/`
- Is this architecture/design? ‚Üí `docs/architecture/`
- Is this specific to an application? ‚Üí `apps/{app}/docs/`
- Is this specific to a package feature? ‚Üí `packages/{package}/docs/`

### Step 2: Choose Appropriate Location

```
# For a new core package feature
‚úÖ packages/core/docs/NEW_FEATURE.md
‚ùå /NEW_FEATURE.md (root directory)

# For console application guide
‚úÖ apps/console/docs/USAGE_GUIDE.md
‚ùå /CONSOLE_USAGE_GUIDE.md (root directory)

# For project-wide implementation summary
‚úÖ docs/development/FEATURE_IMPLEMENTATION.md
‚ùå /IMPLEMENTATION.md (root directory)

# For user guide or tutorial
‚úÖ docs/guides/HOW_TO_DEPLOY.md
‚ùå /DEPLOYMENT.md (root directory)
```

### Step 3: Link from README

Update the relevant README.md to reference your new documentation:

- Main `README.md` for project-level docs
- Package `README.md` for package-specific docs
- Application `README.md` for app-specific docs

---

## üìö Documentation Templates

### Quick Start Template

```markdown
# {Application/Package} Quick Start Guide

## Prerequisites
- List requirements

## Installation
- Step by step

## Usage
- Basic usage examples

## Next Steps
- Links to detailed guides
```

### Implementation/Feature Template

```markdown
# {Feature Name} Implementation

## Overview
Brief description

## Implementation Details
Technical details

## Usage
How to use

## Testing
How to test

## Related Documentation
Links to related docs
```

---

## üîÑ Migration Rules

When AI generates documentation in the root directory:

1. **Immediately recognize** the document type
2. **Move to appropriate location**:

   ```bash
   # Example
   mv ROOT_DOC.md docs/guides/ROOT_DOC.md
   # or
   mv FEATURE_DOC.md packages/core/docs/FEATURE_DOC.md
   ```

3. **Update any references** in other files
4. **Add to relevant README** for discoverability

---

## ‚úÖ Best Practices

1. **Keep root clean**: Only `README.md` and essential project files
2. **Use subdirectories**: Organize by type and scope
3. **Link documents**: Cross-reference related documentation
4. **Update READMEs**: Keep README files up-to-date with doc links
5. **Consistent naming**: Follow naming conventions
6. **Clear hierarchy**: User docs separate from dev docs

---

## üé® Document Structure

### Every Document Should Have

1. **Title** (H1)
2. **Brief description** (1-2 sentences)
3. **Table of contents** (for long docs)
4. **Main content** (well-structured with headings)
5. **Related links** (at the end)
6. **Last updated date** (optional but recommended)

---

## üìñ Examples of Well-Organized Documentation

### Good Examples ‚úÖ

```
packages/core/docs/
‚îú‚îÄ‚îÄ README.md (package overview + links to all docs)
‚îú‚îÄ‚îÄ ORDER_SYNC_MECHANISM.md (feature design)
‚îú‚îÄ‚îÄ ORDER_SYNC_IMPLEMENTATION.md (implementation)
‚îî‚îÄ‚îÄ API_REFERENCE.md (API docs)

apps/console/docs/
‚îú‚îÄ‚îÄ QUICK_START.md (how to start)
‚îú‚îÄ‚îÄ CONFIGURATION.md (config guide)
‚îî‚îÄ‚îÄ DEPLOYMENT.md (deployment guide)

docs/
‚îú‚îÄ‚îÄ guides/
‚îÇ   ‚îú‚îÄ‚îÄ PROJECT_QUICK_START.md
‚îÇ   ‚îî‚îÄ‚îÄ STRATEGY_MANAGEMENT_GUIDE.md
‚îú‚îÄ‚îÄ development/
‚îÇ   ‚îú‚îÄ‚îÄ IMPLEMENTATION_SUMMARY.md
‚îÇ   ‚îî‚îÄ‚îÄ CONSOLE_WEB_IMPROVEMENTS.md
‚îî‚îÄ‚îÄ architecture/
    ‚îî‚îÄ‚îÄ SYSTEM_DESIGN.md
```

### Bad Examples ‚ùå

```
# Don't do this:
‚îú‚îÄ‚îÄ QUICK_START.md (which app?)
‚îú‚îÄ‚îÄ FEATURE_1.md (unclear purpose)
‚îú‚îÄ‚îÄ NEW_IMPLEMENTATION.md (what implementation?)
‚îú‚îÄ‚îÄ DOCS.md (too vague)
‚îî‚îÄ‚îÄ NOTES.md (should be in proper location)
```

---

## ü§ñ AI Agent Instructions

When you (AI) create documentation:

1. **NEVER put files in root directory** (except README.md updates)
2. **ASK** if unclear where to place: "This looks like a {type} document. Should I place it in {location}?"
3. **SUGGEST** appropriate location based on content
4. **CREATE** directory structure if it doesn't exist
5. **UPDATE** relevant README files with links
6. **FOLLOW** naming conventions consistently
7. **DO NOT create summary documents** after completing tasks unless explicitly requested by the user

### Decision Tree for AI

```
Is it a Quick Start?
‚îî‚îÄ Yes ‚Üí apps/{app}/docs/QUICK_START.md
‚îî‚îÄ No ‚Üì

Is it implementation/improvement documentation?
‚îî‚îÄ Yes ‚Üí docs/development/{NAME}.md
‚îî‚îÄ No ‚Üì

Is it a package feature documentation?
‚îî‚îÄ Yes ‚Üí packages/{package}/docs/{FEATURE}.md
‚îî‚îÄ No ‚Üì

Is it a user guide?
‚îî‚îÄ Yes ‚Üí docs/guides/{NAME}.md
‚îî‚îÄ No ‚Üì

Is it architecture/design?
‚îî‚îÄ Yes ‚Üí docs/architecture/{NAME}.md
‚îî‚îÄ No ‚Üì

Is it API reference?
‚îî‚îÄ Yes ‚Üí docs/api/{NAME}.md or packages/{package}/docs/API.md
```

---

## üìå Summary

**Golden Rule**: Documentation should be close to what it documents.

- **Application docs** ‚Üí `apps/{app}/docs/`
- **Package docs** ‚Üí `packages/{package}/docs/`
- **Project docs** ‚Üí `docs/{category}/`
- **Root directory** ‚Üí Keep clean!

When in doubt, put it in `docs/guides/` and organize later.

**Remember**: Good documentation structure makes the project more maintainable and user-friendly! üìö‚ú®

---

## ‚úçÔ∏è Documentation Signature Rules

### Required Ending Signature

**All documentation, posts, and technical articles MUST end with the following signature format:**

```markdown
---

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

### Examples

#### For Documentation Files

```markdown
---

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

#### For Wiki Posts

```markdown
---

*This article is written based on actual development experience of the iTrade project.*

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

#### For Implementation Summaries

```markdown
---

*Implementation completed and verified through automated testing.*

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

### AI Agent Instructions for Signatures

1. **ALWAYS include** the signature at the end of every document
2. **Use the actual current date when you are writing** (e.g., if today is December 10, 2024, use "December 10, 2024")
3. **Do NOT use placeholder text** - always replace with the real current date
4. **Do NOT include version numbers** - only Author and Date
5. **Maintain consistent formatting** with the examples above
6. **Add contextual notes** above the signature when appropriate (e.g., project context, implementation status)

**Critical**:

- When you see `[Current Date in format: Month Day, Year]` in the template, replace it with TODAY'S actual date
- Format: "Month Day, Year" (e.g., "December 10, 2024")
- Use the date when you are actually creating/updating the document, not a fixed date

### Signature Placement

- Place signature **after main content** but **before references/links section**
- Use `---` horizontal rule to separate signature from main content
- Keep signature formatting consistent across all documents

This ensures consistent authorship attribution and helps track document creation/modification dates across the entire project.

---

## üîß Code Quality and Linting Rules

### Mandatory Post-Edit Linting

**After ANY modification to source code or documentation files, AI agents MUST execute appropriate linting commands to ensure code quality and formatting compliance.**

#### Critical Rules Summary

> **üö® MANDATORY: Run `pnpm lint --fix` after EVERY source code modification**
>
> This single command:
>
>
> 1. ‚úÖ Checks TypeScript/JavaScript errors (ESLint)
> 2. ‚úÖ Applies Prettier formatting automatically
> 3. ‚úÖ Fixes import ordering
> 4. ‚úÖ Removes unused imports
> 5. ‚úÖ Ensures consistent code style
>
> **NEVER skip this step. NEVER leave formatting/linting errors.**

#### Required Actions After Code Changes

1. **For TypeScript/JavaScript files** (`.ts`, `.tsx`, `.js`, `.jsx`):

   ```bash
   # Run lint check for the specific project
   pnpm lint                    # For Next.js apps
   npm run lint                 # For other packages
   
   # If linting errors are found, attempt to auto-fix
   pnpm lint --fix             # Auto-fix when possible
   ```

2. **For Markdown files** (`.md`):

   ```bash
   # Check markdown formatting
   pnpm lint                   # If project has markdown linting
   # Or use dedicated markdown linter if available
   ```

3. **For JSON/Config files** (`.json`, `.yaml`, `.yml`):

   ```bash
   # Validate JSON/YAML syntax
   pnpm lint                   # Project-specific linting
   ```

#### Workflow Requirements

1. **ALWAYS run linting** after making code changes
2. **REPORT linting results** to the user
3. **ATTEMPT to fix** common formatting issues automatically
4. **STOP and ask for guidance** if critical errors cannot be auto-fixed
5. **NEVER leave broken code** - ensure all changes compile and pass basic checks

#### Project-Specific Lint Commands

| Project Location | Command | Description |
|------------------|---------|-------------|
| `/apps/web/` | `pnpm lint` | Next.js web application linting |
| `/apps/console/` | `pnpm lint` | Node.js console application linting |
| `/apps/mobile/` | `flutter analyze` | Flutter mobile app analysis |
| `/packages/*/` | `pnpm lint` or `npm run lint` | Package-specific linting |
| Root directory | `pnpm lint:all` | Lint all workspaces (if available) |

#### Error Handling Protocol

```markdown
1. Run appropriate lint command
2. If errors found:
   - Try auto-fix: `pnpm lint --fix`
   - Report remaining errors to user
   - Provide specific line numbers and descriptions
   - Suggest manual fixes if auto-fix failed
3. If critical errors:
   - Do not proceed with additional changes
   - Ask user for guidance on error resolution
4. If warnings only:
   - Report warnings but may proceed
   - Suggest improvements for code quality
```

#### AI Agent Instructions for Linting

1. **EXECUTE linting immediately** after any file modification
2. **ALWAYS run `pnpm lint --fix`** to auto-fix ESLint + Prettier issues
3. **USE the read_lints tool** to check for specific file linting errors
4. **BATCH lint checks** when modifying multiple files in the same project
5. **PRIORITIZE auto-fixable issues** over manual interventions
6. **VERIFY formatting** matches Prettier configuration
7. **DOCUMENT any persistent errors** that require manual attention

**Formatting-Specific Instructions:**

- ‚úÖ Write code with single quotes from the start
- ‚úÖ Add semicolons to all statements
- ‚úÖ Use 2-space indentation
- ‚úÖ Keep lines under 100 characters when practical
- ‚úÖ Run `pnpm lint --fix` immediately after modifications
- ‚úÖ Never complete a task with Prettier errors

#### Example Workflow

```bash
# After modifying apps/web/components/example.tsx
cd apps/web
pnpm lint

# If errors found
pnpm lint --fix

# Check specific file if needed
pnpm lint --file components/example.tsx
```

#### Quality Gates

- **No compilation errors** allowed
- **Critical linting errors** must be resolved
- **Warnings should be minimized** where possible
- **Consistent formatting** across all files
- **Import organization** following project standards

#### Skip Conditions

Linting may be skipped ONLY when:

- User explicitly requests to skip linting
- Working on draft/experimental code that user acknowledges is temporary
- System/configuration files that don't support linting

**Default behavior: ALWAYS run linting unless explicitly told otherwise.**

---

## üé® Code Formatting Rules (Prettier)

### Mandatory Prettier Formatting

**ALL source code modifications MUST follow the Prettier configuration defined in the project. AI agents MUST ensure code is properly formatted before committing changes.**

#### Core Principle

> **"Write code that matches the existing codebase style automatically"**
>
>
> When adding or modifying source code, AI agents MUST:
>
> 1. **Follow Prettier configuration** automatically
> 2. **Run `pnpm lint --fix`** to apply formatting
> 3. **NEVER leave formatting errors** in the code

#### Prettier Configuration Location

- **Root Configuration**: `.prettierrc`, `.prettierrc.json`, or `prettier.config.js`
- **Editor Config**: `.editorconfig` (if present)
- **Package-specific**: May override in package directories

#### Key Formatting Rules (Enforced by Prettier)

Based on the project's Prettier configuration:

| Rule | Setting | Example |
|------|---------|---------|
| **Quote Style** | Single quotes (`'`) | `import { foo } from 'bar';` |
| **Semicolons** | Required (`;`) | `const x = 1;` |
| **Trailing Commas** | ES5 style | `{ a, b, c }` not `{ a, b, c, }` |
| **Line Width** | 80-100 characters | Auto-wrap long lines |
| **Indentation** | 2 spaces | Consistent spacing |
| **Arrow Functions** | Parentheses when needed | `(x) => x + 1` |

#### Automatic Formatting Workflow

**Standard Process:**

```bash
# Step 1: Modify code files
# (AI agent makes changes)

# Step 2: Run linting with auto-fix (includes Prettier)
cd <project-directory>
pnpm lint --fix

# Step 3: Verify no formatting errors remain
pnpm lint

# Step 4: If errors persist, read and fix manually
# (Then rerun Step 2-3)
```

#### Common Prettier Fixes

**1. Quote Style**

```typescript
// ‚ùå BAD (double quotes)
import { Component } from "react"

// ‚úÖ GOOD (single quotes)

import { Component } from 'react';
```

**2. Semicolons**

```typescript
// ‚ùå BAD (missing semicolons)
const x = 1
const y = 2

// ‚úÖ GOOD (with semicolons)

const x = 1;
const y = 2;
```

**3. Long Lines**

```typescript
// ‚ùå BAD (exceeds line width)
const result = someVeryLongFunctionName(param1, param2, param3, param4, param5, param6);

// ‚úÖ GOOD (auto-wrapped)
const result = someVeryLongFunctionName(
  param1,
  param2,
  param3,
  param4,

  param5,
  param6
);
```

**4. Object/Array Formatting**

```typescript
// ‚ùå BAD (inconsistent formatting)
const obj = {a:1,b:2,c:3}

// ‚úÖ GOOD (Prettier formatted)
const obj = { a: 1, b: 2, c: 3 };

// For long objects:
const obj = {

  property1: 'value1',
  property2: 'value2',
  property3: 'value3',
};
```

**5. Import Statements**

```typescript
// ‚ùå BAD (wrong quote style)
import {foo,bar,baz} from "module"

// ‚úÖ GOOD (Prettier formatted)
import { foo, bar, baz } from 'module';
```

#### AI Agent Formatting Protocol

**When writing new code:**

1. ‚úÖ **Write code following Prettier rules from the start**
2. ‚úÖ **Use single quotes** for strings
3. ‚úÖ **Add semicolons** at statement ends
4. ‚úÖ **Keep lines under 100 characters** when possible
5. ‚úÖ **Use consistent spacing** (2 spaces indentation)
6. ‚úÖ **Format imports** properly (single quotes, proper spacing)

**After code modification:**

1. ‚úÖ **ALWAYS run `pnpm lint --fix`** immediately
2. ‚úÖ **Verify formatting** with `pnpm lint`
3. ‚úÖ **Fix any remaining issues** before proceeding
4. ‚úÖ **Report formatting status** to user

**CRITICAL RULE:**

> **NEVER commit or complete a task with Prettier formatting errors. If `pnpm lint --fix` doesn't resolve all issues, manually fix them before proceeding.**

#### Project-Specific Prettier Commands

| Location | Command | Purpose |
|----------|---------|---------|

| `/apps/web/` | `pnpm lint --fix` | Format web app code |
| `/apps/console/` | `pnpm lint --fix` | Format console app code |
| `/packages/*/` | `pnpm lint --fix` | Format package code |
| Root | `pnpm lint:all --fix` | Format entire monorepo |

#### Prettier Integration with Tools

**ESLint Integration:**

- Prettier runs as part of ESLint (`eslint-plugin-prettier`)
- `pnpm lint --fix` applies both ESLint and Prettier fixes
- Conflicts are resolved in favor of Prettier

**Editor Integration:**

- VS Code: Uses workspace Prettier config
- Format on save: Recommended for developers
- AI agents: Must use CLI commands

#### Error Detection and Resolution

**Common Prettier Errors:**

```bash
# Error Example:
./components/example.tsx
12:45  Error: Replace `"react"` with `'react';`  prettier/prettier
15:1   Error: Delete `¬∑¬∑`  prettier/prettier
20:80  Error: Insert `‚èé¬∑¬∑`  prettier/prettier
```

**Resolution Steps:**

1. Run `pnpm lint --fix` (auto-fixes most issues)
2. If errors remain, manually review:
   - Check quote style
   - Verify semicolons
   - Check line length
   - Verify indentation
3. Re-run `pnpm lint --fix`
4. Verify with `pnpm lint`

#### Quality Gates for Formatting

**MUST PASS before task completion:**

- ‚úÖ No Prettier errors in `pnpm lint` output
- ‚úÖ All quotes are single quotes (`'`)
- ‚úÖ All statements end with semicolons (`;`)
- ‚úÖ Indentation is consistent (2 spaces)
- ‚úÖ Line length is reasonable (<100 chars)
- ‚úÖ Imports are properly formatted

#### Skip Conditions

Prettier formatting may be skipped ONLY when:

- User explicitly requests to skip formatting
- Working with auto-generated code that will be regenerated
- Editing non-source files (`.md`, `.txt`, etc.) without Prettier config

**Default behavior: ALWAYS apply Prettier formatting to source code.**

---

## üì¶ Package Build Rules

### Mandatory Package Rebuild

**After ANY modification to source files under `packages/**`, AI agents MUST:**

1. ‚úÖ **Rebuild the modified package** - Compile TypeScript changes
2. ‚úÖ **Rebuild dependent packages** (if any) - Ensure type propagation
3. ‚úÖ **Rebuild web application** - **MANDATORY** final verification step

**This ensures changes are compiled, types are updated, and everything integrates correctly.**

#### When to Rebuild

Rebuild is REQUIRED when modifying:

1. **TypeScript/JavaScript source files** (`packages/*/src/**/*.ts`, `*.tsx`, `*.js`, `*.jsx`)
2. **Entity definitions** (`packages/data-manager/src/entities/**/*.ts`)
3. **Type definitions** (`packages/*/src/types/**/*.ts`)
4. **Repository files** (`packages/data-manager/src/repositories/**/*.ts`)
5. **Any exported modules** that other packages depend on

#### Package Dependencies

```
Common dependency chains:
- data-manager ‚Üí core, strategies, exchange-connectors
- core ‚Üí strategies, exchange-connectors
- utils ‚Üí all packages
- logger ‚Üí all packages
```

#### Rebuild Commands

| Package | Command | Build Time |
|---------|---------|------------|
| `packages/core` | `cd packages/core && pnpm build` | ~2-5s |

| `packages/data-manager` | `cd packages/data-manager && pnpm build` | ~3-8s |
| `packages/strategies` | `cd packages/strategies && pnpm build` | ~2-4s |
| `packages/utils` | `cd packages/utils && pnpm build` | ~1-2s |
| `packages/logger` | `cd packages/logger && pnpm build` | ~1-2s |
| `packages/exchange-connectors` | `cd packages/exchange-connectors && pnpm build` | ~2-4s |

| All packages | `pnpm build --filter "./packages/*"` | ~10-20s |

#### Rebuild Workflow

1. **Identify modified package**:

   ```bash
   # Example: Modified packages/data-manager/src/entities/Strategy.ts
   ```

2. **Rebuild the package**:

   ```bash
   cd packages/data-manager && pnpm build
   ```

3. **Rebuild dependent packages** (if needed):

   ```bash
   # If core depends on data-manager and was using the modified code
   cd packages/core && pnpm build
   ```

4. **Rebuild web application to verify**:

   ```bash
   # ALWAYS rebuild web to ensure everything works
   cd apps/web && pnpm build
   ```

5. **Verify build success**:

   ```bash
   # Check for build errors
   # Ensure no TypeScript compilation errors
   # Confirm web build completes successfully
   ```

#### AI Agent Instructions for Package Builds

1. **ALWAYS rebuild** after modifying package source files
2. **Build in dependency order** (dependencies first, then dependents)
3. **ALWAYS rebuild web application** after package changes to verify integration
4. **Report build status** to the user at each step
5. **If build fails**:
   - Report the exact error
   - Attempt to fix the issue
   - Rebuild after fixing
6. **Batch builds** when modifying multiple packages
7. **Never skip web build** - it's the final verification step

#### Example Workflow

```bash
# Scenario: Modified Strategy entity and StrategyRepository

# Step 1: Identify modified package
echo "Modified: packages/data-manager/src/entities/Strategy.ts"
echo "Modified: packages/data-manager/src/repositories/StrategyRepository.ts"

# Step 2: Rebuild data-manager
cd packages/data-manager
pnpm build

# Step 3: Rebuild dependent packages if needed
# If core/strategies import from data-manager, rebuild them too
cd ../core
pnpm build

# Step 4: ALWAYS rebuild web to verify everything works
cd ../../apps/web
pnpm build

# Step 5: Verify no errors
echo "‚úÖ All packages rebuilt successfully"
echo "‚úÖ Web application build verified"
```

#### Build Optimization

- **Incremental builds**: TypeScript only rebuilds changed files
- **Parallel builds**: Use `pnpm -r --parallel build` for multiple packages
- **Skip if no TypeScript changes**: Don't rebuild for doc-only changes

#### Skip Conditions

Rebuild may be skipped ONLY when:

- Only modifying `.md` documentation files
- Only modifying test files (`*.test.ts`, `*.spec.ts`) in non-published packages
- Only modifying configuration files (`.json`, `.yml`) that don't affect build output
- User explicitly requests to skip rebuild (rare)

#### Common Build Errors and Solutions

| Error | Cause | Solution |
|-------|-------|----------|
| `Cannot find module` | Package not rebuilt | Rebuild the dependency |
| `Type error` | Outdated type definitions | Rebuild packages in order |
| `Circular dependency` | Import cycle | Check and fix imports |
| `Out of memory` | Large build | Increase Node memory |

#### Performance Considerations

- Average single package build: **2-5 seconds**
- Average multi-package build: **10-20 seconds**
- Full monorepo build: **30-60 seconds**
- **Web application build: 3-5 seconds**

**Total time for typical workflow:**

- Single package + web: **5-10 seconds**
- Multiple packages + web: **15-25 seconds**
- Full rebuild + web: **35-65 seconds**

**Always rebuild to avoid runtime errors and type mismatches!**

### Quick Reference

```bash
# Standard workflow (RECOMMENDED)
# 1. Rebuild modified package
cd packages/{package-name} && pnpm build

# 2. Rebuild dependent packages (if any)
cd ../dependent-package && pnpm build

# 3. ALWAYS rebuild web to verify
cd ../../apps/web && pnpm build

# ---

# Alternative: Multiple packages (if interdependent)
cd packages/data-manager && pnpm build && \
cd ../core && pnpm build && \
cd ../strategies && pnpm build && \
cd ../../apps/web && pnpm build

# Alternative: All packages + web at once
pnpm build --filter "./packages/*" && \
cd apps/web && pnpm build

# Alternative: Parallel (faster but harder to debug)
pnpm -r --parallel --filter "./packages/*" build && \
cd apps/web && pnpm build
```

**Critical Rule**: ALWAYS finish with `cd apps/web && pnpm build` to verify integration! üèóÔ∏è‚úÖ

---

## üóÑÔ∏è Database Schema Synchronization Rules

### When to Sync Database Schema

**After ANY modification to database entity definitions under `packages/data-manager/src/entities/`, AI agents MUST synchronize the database schema.**

#### Core Principle

> **"Entity Modified ‚Üí Schema Synced ‚Üí Verified"**
>
> When modifying TypeORM entities, AI agents MUST:
>
> 1. ‚úÖ **Modify the entity** (e.g., add fields, update enums)
> 2. ‚úÖ **Rebuild the data-manager package**
> 3. ‚úÖ **Run schema sync** to update the database
> 4. ‚úÖ **Verify the change** works in the application

#### When Schema Sync is REQUIRED

Schema synchronization is MANDATORY when:

1. **Adding/Modifying Entity Fields**
   - Adding new columns to entities
   - Changing column types or constraints
   - Adding/removing indexes
   - Modifying relationships (foreign keys)

2. **Enum Changes**
   - Adding new enum values (e.g., `StrategyType`, `StrategyStatus`)
   - Removing enum values (caution: may break existing data)
   - Renaming enum values

3. **New Entities**
   - Creating new entity classes
   - New tables that need to be created

4. **Entity Refactoring**
   - Renaming entities (creates new table)
   - Splitting/merging entities

#### Schema Sync Command

```bash
cd packages/data-manager && pnpm run sync-schema
```

**What this does:**
- Connects to the PostgreSQL database
- Compares current schema with entity definitions
- Creates/updates tables automatically
- Adds/updates all indexes
- Updates enum types
- Creates foreign key relationships
- Updates the query-result-cache table

#### Complete Workflow

```bash
# Step 1: Modify entity (e.g., add new enum value to Strategy.ts)
# Edit: packages/data-manager/src/entities/Strategy.ts
# Added: MOVING_WINDOW_GRIDS = 'moving_window_grids' to StrategyType enum

# Step 2: Rebuild data-manager package
cd packages/data-manager
pnpm build

# Step 3: Sync database schema
pnpm run sync-schema

# Step 4: Verify in application
# Test that the new enum value works via API/UI

# Step 5: Rebuild web application
cd ../../apps/web
pnpm build
```

#### AI Agent Instructions for Schema Sync

1. **ALWAYS sync schema** after modifying entities
2. **NEVER skip this step** - database will be out of sync with code
3. **ALWAYS verify** the sync completed successfully
4. **Check for errors** in the sync output
5. **Report sync status** to the user

#### Common Scenarios

**Adding a New Strategy Type:**

```typescript
// 1. Add to StrategyType enum in Strategy.ts
export enum StrategyType {
  MOVING_AVERAGE = 'moving_average',
  RSI = 'rsi',
  NEW_STRATEGY = 'new_strategy', // Added
}

// 2. Run sync-schema
// cd packages/data-manager && pnpm run sync-schema

// 3. Verify it works
// Try creating a strategy with type='new_strategy'
```

**Adding a New Entity Field:**

```typescript
// 1. Add field to entity
@Column({ type: 'text', nullable: true })
newField?: string;

// 2. Rebuild package
// cd packages/data-manager && pnpm build

// 3. Sync schema
// pnpm run sync-schema
```

#### Error Handling

**If sync-schema fails:**

1. **Check database connection**
   - Verify PostgreSQL is running
   - Check `.env` file has correct credentials
   - Ensure database exists

2. **Check for syntax errors**
   - Verify entity decorators are correct
   - Check enum syntax
   - Validate column types

3. **Check for conflicts**
   - Existing data may conflict with new constraints
   - Manual migration may be needed for complex changes

#### Skip Conditions

Schema sync may be skipped ONLY when:

- Only modifying repository logic (no entity changes)
- Only modifying non-entity TypeScript files
- Only updating documentation
- User explicitly requests to skip (rare, not recommended)

**Default behavior: ALWAYS sync schema after entity modifications.**

#### Production Considerations

**For production environments:**
- Consider using TypeORM migrations instead of automatic sync
- Test schema changes in development first
- Backup database before major schema changes
- Document all schema modifications

#### Quick Reference

```bash
# Standard workflow after entity modification
cd packages/data-manager
pnpm build
pnpm run sync-schema

# Verify database updated
# Check application works with new schema

# Rebuild web if needed
cd ../../apps/web
pnpm build
```

**Critical Rule**: ALWAYS run `pnpm run sync-schema` after modifying entity definitions! üóÑÔ∏è‚úÖ

---

## üß™ Verification and Testing Rules

### Mandatory Verification After Changes

**AI agents MUST verify that their modifications work correctly before considering a task complete. The agent is responsible for identifying and resolving issues independently.**

#### Core Principle

> **"Modify ‚Üí Verify ‚Üí Resolve Issues Independently"**
>
> When making ANY code modifications, AI agents MUST:
>
> 1. ‚úÖ **Make the modification**
> 2. ‚úÖ **Verify it works correctly** through appropriate testing
> 3. ‚úÖ **Identify any issues** through testing/logs
> 4. ‚úÖ **Resolve all issues independently** without requiring user intervention
> 5. ‚úÖ **Re-verify** after fixes until everything works
>
> **NEVER mark a task as complete without verification. NEVER leave issues unresolved.**

#### When Verification is REQUIRED

Verification is MANDATORY for:

1. **WebSocket/Network Changes**
   - Exchange connector modifications
   - Subscription/unsubscription logic
   - Real-time data streams
   - API endpoint changes

2. **Core Logic Changes**
   - Trading engine modifications
   - Strategy implementations
   - Order management
   - Risk management

3. **Data Processing Changes**
   - Data normalization/transformation
   - Event handling
   - Message parsing
   - Symbol mapping

4. **UI/Frontend Changes**
   - Component behavior
   - Real-time data display
   - User interactions
   - State management

5. **Database/Persistence Changes**
   - Entity modifications
   - Repository updates
   - Migration scripts
   - Data queries

#### Verification Methods

**1. For Backend/Console Applications:**

```bash
# Run the application and verify behavior
cd apps/console
pnpm dev
# OR use the debugger
# Debug console with ts-node (from launch.json)

# Check logs for:
# - ‚úÖ Successful connections
# - ‚úÖ Expected data flow
# - ‚úÖ No errors or warnings
# - ‚úÖ Correct behavior
```

**2. For WebSocket/Exchange Changes:**

```bash
# Create a test script if needed
# Example: test-binance-ws.js

# Run the test
node test-script.js

# Verify:
# - ‚úÖ Connection established
# - ‚úÖ Subscriptions confirmed
# - ‚úÖ Data received correctly
# - ‚úÖ Unsubscribe works
# - ‚úÖ No connection leaks
```

**3. For Web Application:**

```bash
# Build and run the web app
cd apps/web
pnpm build  # Must pass without errors
pnpm dev    # Verify in browser

# Check:
# - ‚úÖ No build errors
# - ‚úÖ UI renders correctly
# - ‚úÖ Real-time updates work
# - ‚úÖ No console errors
```

**4. For API/REST Endpoints:**

```bash
# Test with curl or similar
curl -X GET http://localhost:3000/api/endpoint

# Verify:
# - ‚úÖ Correct response status
# - ‚úÖ Expected data format
# - ‚úÖ No errors in logs
```

#### Issue Resolution Protocol

**When issues are found during verification:**

1. **IDENTIFY the root cause**
   - Read error messages carefully
   - Check logs for patterns
   - Understand the failure point
   - Trace through code flow

2. **ANALYZE the problem**
   - Is it a logic error?
   - Is it a configuration issue?
   - Is it a timing/async issue?
   - Is it a format/data mismatch?

3. **IMPLEMENT a fix**
   - Make targeted changes
   - Follow coding standards
   - Add logging if needed for debugging
   - Consider edge cases

4. **RE-VERIFY the fix**
   - Rebuild if necessary
   - Run the same verification test
   - Confirm the issue is resolved
   - Check for new issues introduced

5. **REPEAT until all issues are resolved**
   - Don't stop at the first fix
   - Verify comprehensively
   - Ensure stability
   - Clean up debug code if appropriate

#### AI Agent Responsibilities

**The AI agent MUST:**

1. ‚úÖ **Test every modification** before claiming completion
2. ‚úÖ **Verify the ORIGINAL issue is resolved** - Not just that the code compiles
3. ‚úÖ **Read and analyze logs** to identify issues
4. ‚úÖ **Resolve all issues independently** without asking the user to debug
5. ‚úÖ **Re-test after fixes** to confirm resolution
6. ‚úÖ **Add debug logging temporarily** if needed to diagnose issues
7. ‚úÖ **Remove temporary debug code** after verification (unless useful long-term)
8. ‚úÖ **Report test results** clearly to the user

**The AI agent MUST NOT:**

1. ‚ùå **Mark tasks complete without verification**
2. ‚ùå **Ask the user to test** unless explicitly requested
3. ‚ùå **Leave issues unresolved** for the user to fix
4. ‚ùå **Make blind changes** without understanding the problem
5. ‚ùå **Ignore error messages** or warnings in logs
6. ‚ùå **Skip verification** to save time
7. ‚ùå **Assume code works** without evidence

#### Verification Checklist

Before marking a task as complete, verify:

- [ ] **Code compiles** without errors (`pnpm build`)
- [ ] **Linting passes** without errors (`pnpm lint`)
- [ ] **Application runs** without crashes
- [ ] **Expected behavior works** as intended
- [ ] **No error messages** in logs during normal operation
- [ ] **Edge cases handled** appropriately
- [ ] **No regressions** introduced in existing functionality
- [ ] **Performance acceptable** (no obvious degradation)
- [ ] **Resource cleanup** (connections closed, memory freed)

#### Example Verification Workflow

```markdown
### Scenario: Modified Binance WebSocket subscription logic

**Step 1: Make the modification**
- Updated BinanceExchange.ts to use dynamic subscribe/unsubscribe
- Changed WebSocket URL format
- Modified message handling

**Step 2: Rebuild packages**
```bash
cd packages/exchange-connectors && pnpm build
cd ../core && pnpm build
```

**Step 3: Create test script**
```javascript
// test-binance-ws.js
const { BinanceExchange } = require('./dist/index.js');
// ... test subscription/unsubscription
```

**Step 4: Run test and observe**
```bash
node test-binance-ws.js
```

**Step 5: Analyze logs**
```
‚úÖ Binance WebSocket connected
‚úÖ Subscription confirmed
‚úÖ Ticker data received
‚úÖ Unsubscribe successful
‚úÖ TEST PASSED
```

**Step 6: Test in console app**
```bash
# Run console app with debugger
# Verify:
# - EventBus listeners receive data
# - No continuous logging after unsubscribe
# - No memory leaks
```

**Step 7: Fix any issues found**
- Added missing symbol mapping
- Fixed event type handling
- Corrected normalization logic

**Step 8: Re-verify**
- All tests pass
- No errors in logs
- Expected behavior confirmed

**Step 9: Clean up**
- Remove test script
- Remove excessive debug logging (keep useful logs)
- Report success to user
```

#### Time Expectations

Verification should be factored into task estimates:

- Simple changes: **+2-5 minutes** for verification
- Medium changes: **+5-15 minutes** for verification
- Complex changes: **+15-30 minutes** for verification
- Critical changes: **+30-60 minutes** for comprehensive testing

**Verification time is NOT optional. It is part of completing the task correctly.**

#### Continuous Verification During Development

For large/complex tasks:

1. **Verify incrementally** after each logical step
2. **Don't wait until the end** to test everything
3. **Catch issues early** when they're easier to fix
4. **Build confidence** that the approach is correct
5. **Adjust course** if verification reveals problems

#### Reporting to User

**Good reporting includes:**

```markdown
‚úÖ **VERIFICATION COMPLETE**

**Changes Made:**
- Modified BinanceExchange WebSocket handling
- Implemented dynamic subscribe/unsubscribe
- Updated message parsing

**Verification Performed:**
- ‚úÖ Built packages successfully
- ‚úÖ Created and ran test script
- ‚úÖ Verified subscription works
- ‚úÖ Verified unsubscription works
- ‚úÖ Tested in console app
- ‚úÖ Confirmed EventBus receives data
- ‚úÖ No errors in logs

**Issues Found & Resolved:**
1. Symbol mapping was missing ‚Üí Added symbolMap
2. Event format incorrect ‚Üí Updated handleWebSocketMessage
3. Unsubscribe not sending message ‚Üí Added UNSUBSCRIBE logic

**Final Status:**
All functionality verified and working correctly. ‚úÖ
```

**Bad reporting:**

```markdown
‚ùå I've made the changes. Please test it.
‚ùå The code should work now.
‚ùå I think this will fix the issue.
```

### Summary: Verification is Mandatory

> **Every modification MUST be verified. Every issue MUST be resolved. The ORIGINAL user request MUST be confirmed working. The AI agent is responsible for ensuring correctness, not the user.**

**Critical Rules:**

1. **Always verify the ORIGINAL issue** - If the user reported "push data callbacks not showing", verify that push data callbacks ARE now showing, not just that the code builds.
2. **Run the actual application** - Don't assume fixes work without running the real application the user will use.
3. **Check the user's perspective** - Verify from the user's point of view, not just the code's point of view.
4. **Complete the full loop** - Make change ‚Üí Build ‚Üí Run ‚Üí Verify user's original problem is solved.

**Remember**: Untested code is broken code. Verification is not optional‚Äîit's a fundamental part of professional software development. üß™‚úÖ

---

## üß™ Test Execution Rules

### Mandatory Test Execution

**AI agents MUST execute all test files/cases that were written or modified during the task.**

#### When to Execute Tests

Tests MUST be executed when:

1. **New test files are created** - Run the new test immediately after creation
2. **Test files are modified** - Re-run the modified test to verify changes
3. **Source code is modified** - Run related tests to verify no regressions
4. **Completing a task** - Run all relevant tests before marking complete

#### Test Execution Protocol

**For Exchange Connector Tests:**

```bash
# After writing/modifying WebSocket tests
npm run test:binance        # Binance WebSocket test
npm run test:okx            # OKX WebSocket test
npm run test:coinbase       # Coinbase WebSocket test

# After writing/modifying REST API tests
npm run test:binance-rest   # Binance REST API test
npm run test:okx-rest       # OKX REST API test
npm run test:coinbase-rest  # Coinbase REST API test

# Run all tests
npm run test:all-exchanges  # Complete test suite
```

**For Other Tests:**

- Execute using appropriate test command
- Verify exit codes (0 = pass, non-zero = fail)
- Review test output for failures

#### Test Execution Requirements

1. ‚úÖ **Execute IMMEDIATELY after writing** - Don't wait for user to ask
2. ‚úÖ **Verify test passes** - Check exit code and output
3. ‚úÖ **Fix failures before proceeding** - Never leave failing tests
4. ‚úÖ **Report results to user** - Show pass/fail summary
5. ‚úÖ **Document any known limitations** - E.g., "Requires credentials"

#### Handling Test Failures

**When tests fail:**

1. **Read the error output carefully**
2. **Identify the root cause** (not just symptoms)
3. **Fix the issue** in source or test code
4. **Rebuild if necessary** (`pnpm build`)
5. **Re-run the test** to verify fix
6. **Repeat until all tests pass**

#### Known Test Limitations

**Document and accept these limitations:**

- **Coinbase REST API** - Requires authentication for all endpoints (public + private)
- **User Data Tests** - Require API credentials in `.env` file
- **Network Tests** - May fail due to rate limits or network issues

#### Example Test Execution Workflow

```markdown
**Step 1: Write test file**
- Created `test-binance-rest.ts`

**Step 2: Verify types**
```bash
npx tsc --noEmit src/tests/test-binance-rest.ts
‚úÖ Types pass
```

**Step 3: Execute test**
```bash
npm run test:binance-rest
‚úÖ 9/9 tests passed (0.9s)
```

**Step 4: Report to user**
‚úÖ Binance REST API test created and verified!
- All market data endpoints working
- Account endpoints require credentials
- Test completes in <1 second
```

#### AI Agent Test Execution Responsibilities

**The AI agent MUST:**

1. ‚úÖ **Execute ALL new/modified tests** before task completion
2. ‚úÖ **Verify tests pass** (or document known failures)
3. ‚úÖ **Fix any test failures** before marking task complete
4. ‚úÖ **Report test results** clearly to user
5. ‚úÖ **Document test coverage** for the implementation

**The AI agent MUST NOT:**

1. ‚ùå **Skip test execution** to save time
2. ‚ùå **Mark tasks complete** without running tests
3. ‚ùå **Leave failing tests** for the user to fix
4. ‚ùå **Create tests without executing them**

### Summary: Test Execution is Mandatory

> **Every test written MUST be executed. Every test modified MUST be re-run. Test failures MUST be fixed. The AI agent is responsible for ensuring tests pass, not the user.**

**Critical Rule**: If you write a test, you MUST run it immediately and verify it passes! üß™‚úÖ

---

## üöÄ Running Console Application (main.ts)

### Mandatory Execution Method

**When running `apps/console/src/main.ts` for testing or verification, AI agents MUST use the same settings as configured in `.vscode/launch.json` debugger configuration.**

#### Required Execution Command

```bash
cd apps/console && \
NODE_ENV=development \
TS_NODE_PROJECT=tsconfig.build.json \
TS_NODE_FILES=true \
NODE_OPTIONS="--conditions=source" \
node -r ts-node/register \
     -r tsconfig-paths/register \
     -r reflect-metadata \
     src/main.ts
```

#### Why These Settings?

1. **`ts-node/register`** - Enables TypeScript execution without pre-compilation
2. **`tsconfig-paths/register`** - Resolves `@itrade/*` path aliases correctly
3. **`reflect-metadata`** - Required for TypeORM decorators
4. **`TS_NODE_PROJECT=tsconfig.build.json`** - Uses the correct TypeScript configuration
5. **`NODE_OPTIONS="--conditions=source"`** - Ensures source maps work correctly

#### When to Run main.ts

Run `main.ts` when:

1. **Verifying TradingEngine integration** after exchange connector changes
2. **Testing user data subscriptions** for all exchanges
3. **Verifying strategy subscriptions** work correctly
4. **Checking EventBus emissions** from exchanges
5. **Validating database connectivity** and entity persistence
6. **Testing graceful shutdown** and cleanup

#### Running with Timeout

For automated testing (non-interactive):

```bash
cd apps/console && \
(NODE_ENV=development \
 TS_NODE_PROJECT=tsconfig.build.json \
 TS_NODE_FILES=true \
 NODE_OPTIONS="--conditions=source" \
 node -r ts-node/register \
      -r tsconfig-paths/register \
      -r reflect-metadata \
      src/main.ts 2>&1 & PID=$!; \
 sleep 15; \
 kill $PID 2>/dev/null; \
 wait $PID 2>/dev/null) | grep -E "‚úÖ|üì°|üîç|Balance|Position|Order"
```

#### Expected Output

When running successfully, you should see:

- ‚úÖ Database connected
- ‚úÖ Exchange(s) initialized (Binance, OKX, Coinbase)
- ‚úÖ Subscribed to user data for each exchange
- üìä Position/Balance/Order updates (if available)
- üöÄ Trading System is LIVE

#### Known Issues

- **Binance 401 Unauthorized**: API key permissions or IP whitelisting issue (external config, not code bug)
- **OKX Invalid Timestamp**: Incorrect timestamp format (should be fixed in code)
- **Coinbase 401 Unauthorized**: Requires valid credentials for REST API (WebSocket public data doesn't require auth)
- **TypeORM Decorator Error**: Packages need to be rebuilt (`pnpm build --filter "./packages/*"`)

#### Critical Rules

1. ‚ùå **NEVER use `npm run dev`** - It uses `tsx` which has different module resolution
2. ‚ùå **NEVER use `tsx src/main.ts`** - It bypasses required registrations
3. ‚úÖ **ALWAYS use the command above** - It matches the debugger configuration
4. ‚úÖ **ALWAYS rebuild packages first** if you get "Cannot find module" errors
5. ‚úÖ **ALWAYS verify exchanges connect** and user data subscriptions work

### Summary: Use Debugger Settings for main.ts

> **When running `main.ts`, ALWAYS use the exact same settings as `.vscode/launch.json` to ensure consistent behavior between AI testing and user debugging.**

---

## üîç TypeScript Code Quality Verification Rules

### Mandatory Verification After TypeScript Code Changes

**When ANY TypeScript code (.ts, .tsx files) in a package is modified, added, or deleted, AI agents MUST execute the following verification steps:**

#### Core Principle

> **"Code Modified ‚Üí Lint & TypeCheck ‚Üí Verify Applications"**
>
> After modifying TypeScript code in any package:
>
> 1. ‚úÖ **Verify the modified package** - Run lint and typecheck in the current package
> 2. ‚úÖ **Verify dependent applications** - Run lint and typecheck in `apps/web` and `apps/console`
> 3. ‚úÖ **Fix all errors** before marking task complete
> 4. ‚úÖ **Never skip verification** - Type safety is critical

#### When Verification is REQUIRED

Verification is MANDATORY when modifying:

1. **Package Source Files** (`packages/*/src/**/*.ts`, `*.tsx`)
   - Entity definitions
   - Type definitions
   - Repository files
   - Service implementations
   - Utility functions
   - Any exported modules

2. **Application Source Files** (`apps/*/src/**/*.ts`, `*.tsx`)
   - Components
   - Pages
   - API routes
   - Server code
   - Client code

#### Verification Commands

**For Modified Package:**

```bash
# Step 1: Navigate to the modified package
cd packages/{package-name}

# Step 2: Run lint
pnpm lint

# Step 3: Run typecheck
pnpm typecheck

# Step 4: Fix any errors
pnpm lint --fix  # Auto-fix lint issues
# Then manually fix any remaining typecheck errors
```

**For Dependent Applications (ALWAYS):**

```bash
# Step 1: Verify web application
cd apps/web
pnpm lint
pnpm typecheck

# Step 2: Verify console application
cd apps/console
pnpm lint
pnpm typecheck
```

#### Complete Verification Workflow

```bash
# Example: After modifying packages/core/src/types/index.ts

# 1. Verify the modified package
cd packages/core
pnpm lint
pnpm typecheck

# 2. If errors found, fix them
pnpm lint --fix
# Fix typecheck errors manually

# 3. Rebuild the package (critical for type propagation)
pnpm build

# 4. Verify web application
cd ../../apps/web
pnpm lint
pnpm typecheck

# 5. Verify console application
cd ../console
pnpm lint
pnpm typecheck

# 6. If web/console have errors, fix them
# This ensures the package changes integrate correctly
```

#### AI Agent Responsibilities

**The AI agent MUST:**

1. ‚úÖ **Run lint and typecheck** on the modified package immediately after changes
2. ‚úÖ **Run lint and typecheck** on `apps/web` and `apps/console` after package changes
3. ‚úÖ **Rebuild the package** before verifying applications (for type propagation)
4. ‚úÖ **Fix all lint and typecheck errors** before completing the task
5. ‚úÖ **Report verification results** clearly to the user
6. ‚úÖ **Never skip verification** even if changes seem minor

**The AI agent MUST NOT:**

1. ‚ùå **Mark tasks complete** without running verification
2. ‚ùå **Skip application verification** after package changes
3. ‚ùå **Leave lint or typecheck errors** for the user to fix
4. ‚ùå **Assume changes are safe** without verification
5. ‚ùå **Skip rebuilding packages** before application verification

#### Verification Checklist

Before marking a TypeScript modification task as complete:

- [ ] **Modified package: lint passed** (`pnpm lint`)
- [ ] **Modified package: typecheck passed** (`pnpm typecheck`)
- [ ] **Modified package: rebuilt** (`pnpm build`)
- [ ] **Web app: lint passed** (`cd apps/web && pnpm lint`)
- [ ] **Web app: typecheck passed** (`cd apps/web && pnpm typecheck`)
- [ ] **Console app: lint passed** (`cd apps/console && pnpm lint`)
- [ ] **Console app: typecheck passed** (`cd apps/console && pnpm typecheck`)
- [ ] **All errors fixed** (no lint or typecheck errors remaining)

#### Quick Reference Commands

```bash
# Verify entire workspace (all packages and apps)
cd /path/to/iTrade
pnpm lint
pnpm typecheck

# These commands run sequentially through all workspace projects
# Errors will be displayed clearly for each package/app
```

#### Common Verification Scenarios

**Scenario 1: Modified a package entity/type**

```bash
# 1. Modified: packages/core/src/types/index.ts
cd packages/core
pnpm lint && pnpm typecheck && pnpm build

# 2. Verify apps use the updated types correctly
cd ../../apps/web && pnpm typecheck
cd ../console && pnpm typecheck
```

**Scenario 2: Modified a package service**

```bash
# 1. Modified: packages/exchange-connectors/src/binance/BinanceExchange.ts
cd packages/exchange-connectors
pnpm lint && pnpm typecheck && pnpm build

# 2. Verify apps integrate correctly
cd ../../apps/console && pnpm lint && pnpm typecheck
cd ../web && pnpm lint && pnpm typecheck
```

**Scenario 3: Modified multiple packages**

```bash
# 1. Verify each modified package
cd packages/core && pnpm lint && pnpm typecheck && pnpm build
cd ../data-manager && pnpm lint && pnpm typecheck && pnpm build

# 2. Verify both applications once at the end
cd ../../apps/web && pnpm lint && pnpm typecheck
cd ../console && pnpm lint && pnpm typecheck
```

#### Error Resolution Protocol

**When verification fails:**

1. **Read the error message carefully** - Understand what failed
2. **Identify the root cause** - Is it lint, typecheck, or integration?
3. **Fix the error** - Make necessary code changes
4. **Re-run verification** - Ensure the fix works
5. **Verify applications again** - Ensure integration still works
6. **Repeat until all pass** - Don't stop until everything is green

#### Skip Conditions

Verification may be skipped ONLY when:

- Only modifying `.md` documentation files
- Only modifying configuration files that don't affect types (`.json`, `.yml`)
- Only modifying test files that don't export types
- User explicitly requests to skip (rare, not recommended)

**Default behavior: ALWAYS verify TypeScript code changes.**

### Summary: TypeScript Verification is Mandatory

> **Every TypeScript code modification MUST be verified through lint and typecheck in both the modified package AND dependent applications (web/console). Type safety is non-negotiable.**

**Critical Rules:**

1. **Always run verification** after modifying TypeScript code
2. **Always verify applications** after package changes
3. **Always rebuild packages** before application verification
4. **Always fix all errors** before completing tasks
5. **Never skip verification** - Type errors cause runtime failures

**Remember**: Unverified TypeScript changes lead to runtime errors and integration issues. Verification is not optional‚Äîit's a fundamental part of professional TypeScript development. üîç‚úÖ
