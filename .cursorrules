# iTrade Project - AI Agent Documentation Rules

## üìÇ Documentation Structure

When creating or modifying documentation files, follow this structure:

### Root Level

- `README.md` - Project overview and main documentation entry point
- Keep root directory clean, avoid creating new documentation files here

### Documentation Directories

#### `/docs/` - Project-level Documentation

Main documentation hub for the entire project.

**Subdirectories:**

- `/docs/guides/` - User guides and tutorials
  - Quick start guides
  - How-to guides
  - Best practices
  - Examples: `PROJECT_QUICK_START.md`, `RUN_COMMANDS.md`, `STRATEGY_MANAGEMENT_GUIDE.md`

- `/docs/development/` - Development process documentation
  - Implementation summaries
  - Improvement logs
  - Migration guides
  - Bug fixes documentation
  - Examples: `CONSOLE_WEB_IMPROVEMENTS.md`, `IMPLEMENTATION_SUMMARY.md`, `IMPROVEMENTS_SUMMARY.md`

- `/docs/api/` - API reference documentation
  - Existing: `API-REFERENCE-MARKET-DATA.md`
  - API specifications
  - Interface documentation

- `/docs/architecture/` - Architecture and design documentation
  - System design documents
  - Architecture decisions (ADR)
  - Technical specifications
  - Existing: `DESIGN-ANALYSIS-MARKET-DATA-API.md`, `trading-engine-analysis.md`

#### Application-Specific Documentation

**Console Application** - `/apps/console/docs/`

- `QUICK_START.md` - Console quick start guide
- Application-specific guides
- Console configuration

**Web Application** - `/apps/web/docs/`

- Web application guides
- API documentation
- Deployment guides

**Mobile Application** - `/apps/mobile/docs/`

- Mobile setup guides
- Platform-specific documentation
- Build instructions

#### Package-Specific Documentation

**Core Package** - `/packages/core/docs/`

- Core functionality documentation
- Examples: `ORDER_SYNC_MECHANISM.md`, `ORDER_SYNC_IMPLEMENTATION.md`
- API reference for core modules

**Data Manager** - `/packages/data-manager/docs/`

- Database schema documentation
- Data migration guides

**Exchange Connectors** - `/packages/exchange-connectors/docs/`

- Exchange integration guides
- Per-exchange documentation

**Other Packages** - `/packages/{package-name}/docs/`

- Package-specific documentation
- Usage examples
- API reference

---

## üìù Documentation Naming Conventions

### File Names

- Use `UPPERCASE_WITH_UNDERSCORES.md` for important top-level docs
- Use `lowercase-with-hyphens.md` for regular documentation
- Use descriptive names: `QUICK_START.md`, `API_REFERENCE.md`

### Bilingual Documentation Naming

**Default Language**: English (no suffix)
**Chinese Version**: Add `_CN` suffix

Examples:

- `README.md` - English (default)
- `README_CN.md` - Chinese version
- `QUICK_START.md` - English
- `QUICK_START_CN.md` - Chinese version
- `API_REFERENCE.md` - English
- `API_REFERENCE_CN.md` - Chinese version

**Rationale**:

- English is the international standard for open-source projects
- Cursor AI and most development tools work best with English
- Makes the project more accessible to global developers

### Document Types and Locations

| Document Type | Location | Example |
|--------------|----------|---------|
| Quick Start Guide | `{app}/docs/QUICK_START.md` | `apps/console/docs/QUICK_START.md` |
| User Guide | `docs/guides/` | `docs/guides/STRATEGY_MANAGEMENT_GUIDE.md` |
| API Reference | `docs/api/` or `{package}/docs/` | `packages/core/docs/API_REFERENCE.md` |
| Implementation Log | `docs/development/` | `docs/development/IMPLEMENTATION_SUMMARY.md` |
| Architecture Doc | `docs/architecture/` | `docs/architecture/SYSTEM_DESIGN.md` |
| Package Feature Doc | `{package}/docs/` | `packages/core/docs/ORDER_SYNC_MECHANISM.md` |
| Troubleshooting | `docs/guides/` | `docs/guides/TROUBLESHOOTING.md` |
| Changelog | `docs/development/` | `docs/development/CHANGELOG.md` |

---

## üéØ When Creating New Documentation

### Step 1: Determine Document Type

Ask yourself:

- Is this a user guide? ‚Üí `docs/guides/`
- Is this implementation/improvement documentation? ‚Üí `docs/development/`
- Is this API reference? ‚Üí `docs/api/` or `{package}/docs/`
- Is this architecture/design? ‚Üí `docs/architecture/`
- Is this specific to an application? ‚Üí `apps/{app}/docs/`
- Is this specific to a package feature? ‚Üí `packages/{package}/docs/`

### Step 2: Choose Appropriate Location

```
# For a new core package feature
‚úÖ packages/core/docs/NEW_FEATURE.md
‚ùå /NEW_FEATURE.md (root directory)

# For console application guide
‚úÖ apps/console/docs/USAGE_GUIDE.md
‚ùå /CONSOLE_USAGE_GUIDE.md (root directory)

# For project-wide implementation summary
‚úÖ docs/development/FEATURE_IMPLEMENTATION.md
‚ùå /IMPLEMENTATION.md (root directory)

# For user guide or tutorial
‚úÖ docs/guides/HOW_TO_DEPLOY.md
‚ùå /DEPLOYMENT.md (root directory)
```

### Step 3: Link from README

Update the relevant README.md to reference your new documentation:

- Main `README.md` for project-level docs
- Package `README.md` for package-specific docs
- Application `README.md` for app-specific docs

---

## üìö Documentation Templates

### Quick Start Template

```markdown
# {Application/Package} Quick Start Guide

## Prerequisites
- List requirements

## Installation
- Step by step

## Usage
- Basic usage examples

## Next Steps
- Links to detailed guides
```

### Implementation/Feature Template

```markdown
# {Feature Name} Implementation

## Overview
Brief description

## Implementation Details
Technical details

## Usage
How to use

## Testing
How to test

## Related Documentation
Links to related docs
```

---

## üîÑ Migration Rules

When AI generates documentation in the root directory:

1. **Immediately recognize** the document type
2. **Move to appropriate location**:

   ```bash
   # Example
   mv ROOT_DOC.md docs/guides/ROOT_DOC.md
   # or
   mv FEATURE_DOC.md packages/core/docs/FEATURE_DOC.md
   ```

3. **Update any references** in other files
4. **Add to relevant README** for discoverability

---

## ‚úÖ Best Practices

1. **Keep root clean**: Only `README.md` and essential project files
2. **Use subdirectories**: Organize by type and scope
3. **Link documents**: Cross-reference related documentation
4. **Update READMEs**: Keep README files up-to-date with doc links
5. **Consistent naming**: Follow naming conventions
6. **Clear hierarchy**: User docs separate from dev docs

---

## üé® Document Structure

### Every Document Should Have

1. **Title** (H1)
2. **Brief description** (1-2 sentences)
3. **Table of contents** (for long docs)
4. **Main content** (well-structured with headings)
5. **Related links** (at the end)
6. **Last updated date** (optional but recommended)

---

## üìñ Examples of Well-Organized Documentation

### Good Examples ‚úÖ

```
packages/core/docs/
‚îú‚îÄ‚îÄ README.md (package overview + links to all docs)
‚îú‚îÄ‚îÄ ORDER_SYNC_MECHANISM.md (feature design)
‚îú‚îÄ‚îÄ ORDER_SYNC_IMPLEMENTATION.md (implementation)
‚îî‚îÄ‚îÄ API_REFERENCE.md (API docs)

apps/console/docs/
‚îú‚îÄ‚îÄ QUICK_START.md (how to start)
‚îú‚îÄ‚îÄ CONFIGURATION.md (config guide)
‚îî‚îÄ‚îÄ DEPLOYMENT.md (deployment guide)

docs/
‚îú‚îÄ‚îÄ guides/
‚îÇ   ‚îú‚îÄ‚îÄ PROJECT_QUICK_START.md
‚îÇ   ‚îî‚îÄ‚îÄ STRATEGY_MANAGEMENT_GUIDE.md
‚îú‚îÄ‚îÄ development/
‚îÇ   ‚îú‚îÄ‚îÄ IMPLEMENTATION_SUMMARY.md
‚îÇ   ‚îî‚îÄ‚îÄ CONSOLE_WEB_IMPROVEMENTS.md
‚îî‚îÄ‚îÄ architecture/
    ‚îî‚îÄ‚îÄ SYSTEM_DESIGN.md
```

### Bad Examples ‚ùå

```
# Don't do this:
‚îú‚îÄ‚îÄ QUICK_START.md (which app?)
‚îú‚îÄ‚îÄ FEATURE_1.md (unclear purpose)
‚îú‚îÄ‚îÄ NEW_IMPLEMENTATION.md (what implementation?)
‚îú‚îÄ‚îÄ DOCS.md (too vague)
‚îî‚îÄ‚îÄ NOTES.md (should be in proper location)
```

---

## ü§ñ AI Agent Instructions

When you (AI) create documentation:

1. **NEVER put files in root directory** (except README.md updates)
2. **ASK** if unclear where to place: "This looks like a {type} document. Should I place it in {location}?"
3. **SUGGEST** appropriate location based on content
4. **CREATE** directory structure if it doesn't exist
5. **UPDATE** relevant README files with links
6. **FOLLOW** naming conventions consistently
7. **DO NOT create summary documents** after completing tasks unless explicitly requested by the user

### Decision Tree for AI

```
Is it a Quick Start?
‚îî‚îÄ Yes ‚Üí apps/{app}/docs/QUICK_START.md
‚îî‚îÄ No ‚Üì

Is it implementation/improvement documentation?
‚îî‚îÄ Yes ‚Üí docs/development/{NAME}.md
‚îî‚îÄ No ‚Üì

Is it a package feature documentation?
‚îî‚îÄ Yes ‚Üí packages/{package}/docs/{FEATURE}.md
‚îî‚îÄ No ‚Üì

Is it a user guide?
‚îî‚îÄ Yes ‚Üí docs/guides/{NAME}.md
‚îî‚îÄ No ‚Üì

Is it architecture/design?
‚îî‚îÄ Yes ‚Üí docs/architecture/{NAME}.md
‚îî‚îÄ No ‚Üì

Is it API reference?
‚îî‚îÄ Yes ‚Üí docs/api/{NAME}.md or packages/{package}/docs/API.md
```

---

## üìå Summary

**Golden Rule**: Documentation should be close to what it documents.

- **Application docs** ‚Üí `apps/{app}/docs/`
- **Package docs** ‚Üí `packages/{package}/docs/`
- **Project docs** ‚Üí `docs/{category}/`
- **Root directory** ‚Üí Keep clean!

When in doubt, put it in `docs/guides/` and organize later.

**Remember**: Good documentation structure makes the project more maintainable and user-friendly! üìö‚ú®

---

## ‚úçÔ∏è Documentation Signature Rules

### Required Ending Signature

**All documentation, posts, and technical articles MUST end with the following signature format:**

```markdown
---

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

### Examples

#### For Documentation Files

```markdown
---

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

#### For Wiki Posts

```markdown
---

*This article is written based on actual development experience of the iTrade project.*

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

#### For Implementation Summaries

```markdown
---

*Implementation completed and verified through automated testing.*

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

### AI Agent Instructions for Signatures

1. **ALWAYS include** the signature at the end of every document
2. **Use the actual current date when you are writing** (e.g., if today is December 10, 2024, use "December 10, 2024")
3. **Do NOT use placeholder text** - always replace with the real current date
4. **Do NOT include version numbers** - only Author and Date
5. **Maintain consistent formatting** with the examples above
6. **Add contextual notes** above the signature when appropriate (e.g., project context, implementation status)

**Critical**:

- When you see `[Current Date in format: Month Day, Year]` in the template, replace it with TODAY'S actual date
- Format: "Month Day, Year" (e.g., "December 10, 2024")
- Use the date when you are actually creating/updating the document, not a fixed date

### Signature Placement

- Place signature **after main content** but **before references/links section**
- Use `---` horizontal rule to separate signature from main content
- Keep signature formatting consistent across all documents

This ensures consistent authorship attribution and helps track document creation/modification dates across the entire project.

---

## üîß Code Quality and Linting Rules

### Mandatory Post-Edit Linting

**After ANY modification to source code or documentation files, AI agents MUST execute appropriate linting commands to ensure code quality and formatting compliance.**

#### Critical Rules Summary

> **üö® MANDATORY: Run `pnpm lint --fix` after EVERY source code modification**
>
> This single command:
>
>
> 1. ‚úÖ Checks TypeScript/JavaScript errors (ESLint)
> 2. ‚úÖ Applies Prettier formatting automatically
> 3. ‚úÖ Fixes import ordering
> 4. ‚úÖ Removes unused imports
> 5. ‚úÖ Ensures consistent code style
>
> **NEVER skip this step. NEVER leave formatting/linting errors.**

#### Required Actions After Code Changes

1. **For TypeScript/JavaScript files** (`.ts`, `.tsx`, `.js`, `.jsx`):

   ```bash
   # Run lint check for the specific project
   pnpm lint                    # For Next.js apps
   npm run lint                 # For other packages
   
   # If linting errors are found, attempt to auto-fix
   pnpm lint --fix             # Auto-fix when possible
   ```

2. **For Markdown files** (`.md`):

   ```bash
   # Check markdown formatting
   pnpm lint                   # If project has markdown linting
   # Or use dedicated markdown linter if available
   ```

3. **For JSON/Config files** (`.json`, `.yaml`, `.yml`):

   ```bash
   # Validate JSON/YAML syntax
   pnpm lint                   # Project-specific linting
   ```

#### Workflow Requirements

1. **ALWAYS run linting** after making code changes
2. **REPORT linting results** to the user
3. **ATTEMPT to fix** common formatting issues automatically
4. **STOP and ask for guidance** if critical errors cannot be auto-fixed
5. **NEVER leave broken code** - ensure all changes compile and pass basic checks

#### Project-Specific Lint Commands

| Project Location | Command | Description |
|------------------|---------|-------------|
| `/apps/web/` | `pnpm lint` | Next.js web application linting |
| `/apps/console/` | `pnpm lint` | Node.js console application linting |
| `/apps/mobile/` | `flutter analyze` | Flutter mobile app analysis |
| `/packages/*/` | `pnpm lint` or `npm run lint` | Package-specific linting |
| Root directory | `pnpm lint:all` | Lint all workspaces (if available) |

#### Error Handling Protocol

```markdown
1. Run appropriate lint command
2. If errors found:
   - Try auto-fix: `pnpm lint --fix`
   - Report remaining errors to user
   - Provide specific line numbers and descriptions
   - Suggest manual fixes if auto-fix failed
3. If critical errors:
   - Do not proceed with additional changes
   - Ask user for guidance on error resolution
4. If warnings only:
   - Report warnings but may proceed
   - Suggest improvements for code quality
```

#### AI Agent Instructions for Linting

1. **EXECUTE linting immediately** after any file modification
2. **ALWAYS run `pnpm lint --fix`** to auto-fix ESLint + Prettier issues
3. **USE the read_lints tool** to check for specific file linting errors
4. **BATCH lint checks** when modifying multiple files in the same project
5. **PRIORITIZE auto-fixable issues** over manual interventions
6. **VERIFY formatting** matches Prettier configuration
7. **DOCUMENT any persistent errors** that require manual attention

**Formatting-Specific Instructions:**

- ‚úÖ Write code with single quotes from the start
- ‚úÖ Add semicolons to all statements
- ‚úÖ Use 2-space indentation
- ‚úÖ Keep lines under 100 characters when practical
- ‚úÖ Run `pnpm lint --fix` immediately after modifications
- ‚úÖ Never complete a task with Prettier errors

#### Example Workflow

```bash
# After modifying apps/web/components/example.tsx
cd apps/web
pnpm lint

# If errors found
pnpm lint --fix

# Check specific file if needed
pnpm lint --file components/example.tsx
```

#### Quality Gates

- **No compilation errors** allowed
- **Critical linting errors** must be resolved
- **Warnings should be minimized** where possible
- **Consistent formatting** across all files
- **Import organization** following project standards

#### Skip Conditions

Linting may be skipped ONLY when:

- User explicitly requests to skip linting
- Working on draft/experimental code that user acknowledges is temporary
- System/configuration files that don't support linting

**Default behavior: ALWAYS run linting unless explicitly told otherwise.**

---

## üé® Code Formatting Rules (Prettier)

### Mandatory Prettier Formatting

**ALL source code modifications MUST follow the Prettier configuration defined in the project. AI agents MUST ensure code is properly formatted before committing changes.**

#### Core Principle

> **"Write code that matches the existing codebase style automatically"**
>
>
> When adding or modifying source code, AI agents MUST:
>
> 1. **Follow Prettier configuration** automatically
> 2. **Run `pnpm lint --fix`** to apply formatting
> 3. **NEVER leave formatting errors** in the code

#### Prettier Configuration Location

- **Root Configuration**: `.prettierrc`, `.prettierrc.json`, or `prettier.config.js`
- **Editor Config**: `.editorconfig` (if present)
- **Package-specific**: May override in package directories

#### Key Formatting Rules (Enforced by Prettier)

Based on the project's Prettier configuration:

| Rule | Setting | Example |
|------|---------|---------|
| **Quote Style** | Single quotes (`'`) | `import { foo } from 'bar';` |
| **Semicolons** | Required (`;`) | `const x = 1;` |
| **Trailing Commas** | ES5 style | `{ a, b, c }` not `{ a, b, c, }` |
| **Line Width** | 80-100 characters | Auto-wrap long lines |
| **Indentation** | 2 spaces | Consistent spacing |
| **Arrow Functions** | Parentheses when needed | `(x) => x + 1` |

#### Automatic Formatting Workflow

**Standard Process:**

```bash
# Step 1: Modify code files
# (AI agent makes changes)

# Step 2: Run linting with auto-fix (includes Prettier)
cd <project-directory>
pnpm lint --fix

# Step 3: Verify no formatting errors remain
pnpm lint

# Step 4: If errors persist, read and fix manually
# (Then rerun Step 2-3)
```

#### Common Prettier Fixes

**1. Quote Style**

```typescript
// ‚ùå BAD (double quotes)
import { Component } from "react"

// ‚úÖ GOOD (single quotes)

import { Component } from 'react';
```

**2. Semicolons**

```typescript
// ‚ùå BAD (missing semicolons)
const x = 1
const y = 2

// ‚úÖ GOOD (with semicolons)

const x = 1;
const y = 2;
```

**3. Long Lines**

```typescript
// ‚ùå BAD (exceeds line width)
const result = someVeryLongFunctionName(param1, param2, param3, param4, param5, param6);

// ‚úÖ GOOD (auto-wrapped)
const result = someVeryLongFunctionName(
  param1,
  param2,
  param3,
  param4,

  param5,
  param6
);
```

**4. Object/Array Formatting**

```typescript
// ‚ùå BAD (inconsistent formatting)
const obj = {a:1,b:2,c:3}

// ‚úÖ GOOD (Prettier formatted)
const obj = { a: 1, b: 2, c: 3 };

// For long objects:
const obj = {

  property1: 'value1',
  property2: 'value2',
  property3: 'value3',
};
```

**5. Import Statements**

```typescript
// ‚ùå BAD (wrong quote style)
import {foo,bar,baz} from "module"

// ‚úÖ GOOD (Prettier formatted)
import { foo, bar, baz } from 'module';
```

#### AI Agent Formatting Protocol

**When writing new code:**

1. ‚úÖ **Write code following Prettier rules from the start**
2. ‚úÖ **Use single quotes** for strings
3. ‚úÖ **Add semicolons** at statement ends
4. ‚úÖ **Keep lines under 100 characters** when possible
5. ‚úÖ **Use consistent spacing** (2 spaces indentation)
6. ‚úÖ **Format imports** properly (single quotes, proper spacing)

**After code modification:**

1. ‚úÖ **ALWAYS run `pnpm lint --fix`** immediately
2. ‚úÖ **Verify formatting** with `pnpm lint`
3. ‚úÖ **Fix any remaining issues** before proceeding
4. ‚úÖ **Report formatting status** to user

**CRITICAL RULE:**

> **NEVER commit or complete a task with Prettier formatting errors. If `pnpm lint --fix` doesn't resolve all issues, manually fix them before proceeding.**

#### Project-Specific Prettier Commands

| Location | Command | Purpose |
|----------|---------|---------|

| `/apps/web/` | `pnpm lint --fix` | Format web app code |
| `/apps/console/` | `pnpm lint --fix` | Format console app code |
| `/packages/*/` | `pnpm lint --fix` | Format package code |
| Root | `pnpm lint:all --fix` | Format entire monorepo |

#### Prettier Integration with Tools

**ESLint Integration:**

- Prettier runs as part of ESLint (`eslint-plugin-prettier`)
- `pnpm lint --fix` applies both ESLint and Prettier fixes
- Conflicts are resolved in favor of Prettier

**Editor Integration:**

- VS Code: Uses workspace Prettier config
- Format on save: Recommended for developers
- AI agents: Must use CLI commands

#### Error Detection and Resolution

**Common Prettier Errors:**

```bash
# Error Example:
./components/example.tsx
12:45  Error: Replace `"react"` with `'react';`  prettier/prettier
15:1   Error: Delete `¬∑¬∑`  prettier/prettier
20:80  Error: Insert `‚èé¬∑¬∑`  prettier/prettier
```

**Resolution Steps:**

1. Run `pnpm lint --fix` (auto-fixes most issues)
2. If errors remain, manually review:
   - Check quote style
   - Verify semicolons
   - Check line length
   - Verify indentation
3. Re-run `pnpm lint --fix`
4. Verify with `pnpm lint`

#### Quality Gates for Formatting

**MUST PASS before task completion:**

- ‚úÖ No Prettier errors in `pnpm lint` output
- ‚úÖ All quotes are single quotes (`'`)
- ‚úÖ All statements end with semicolons (`;`)
- ‚úÖ Indentation is consistent (2 spaces)
- ‚úÖ Line length is reasonable (<100 chars)
- ‚úÖ Imports are properly formatted

#### Skip Conditions

Prettier formatting may be skipped ONLY when:

- User explicitly requests to skip formatting
- Working with auto-generated code that will be regenerated
- Editing non-source files (`.md`, `.txt`, etc.) without Prettier config

**Default behavior: ALWAYS apply Prettier formatting to source code.**

---

## üì¶ Package Build Rules

### Mandatory Package Rebuild

**After ANY modification to source files under `packages/**`, AI agents MUST:**

1. ‚úÖ **Rebuild the modified package** - Compile TypeScript changes
2. ‚úÖ **Rebuild dependent packages** (if any) - Ensure type propagation
3. ‚úÖ **Rebuild web application** - **MANDATORY** final verification step

**This ensures changes are compiled, types are updated, and everything integrates correctly.**

#### When to Rebuild

Rebuild is REQUIRED when modifying:

1. **TypeScript/JavaScript source files** (`packages/*/src/**/*.ts`, `*.tsx`, `*.js`, `*.jsx`)
2. **Entity definitions** (`packages/data-manager/src/entities/**/*.ts`)
3. **Type definitions** (`packages/*/src/types/**/*.ts`)
4. **Repository files** (`packages/data-manager/src/repositories/**/*.ts`)
5. **Any exported modules** that other packages depend on

#### Package Dependencies

```
Common dependency chains:
- data-manager ‚Üí core, strategies, exchange-connectors
- core ‚Üí strategies, exchange-connectors
- utils ‚Üí all packages
- logger ‚Üí all packages
```

#### Rebuild Commands

| Package | Command | Build Time |
|---------|---------|------------|
| `packages/core` | `cd packages/core && pnpm build` | ~2-5s |

| `packages/data-manager` | `cd packages/data-manager && pnpm build` | ~3-8s |
| `packages/strategies` | `cd packages/strategies && pnpm build` | ~2-4s |
| `packages/utils` | `cd packages/utils && pnpm build` | ~1-2s |
| `packages/logger` | `cd packages/logger && pnpm build` | ~1-2s |
| `packages/exchange-connectors` | `cd packages/exchange-connectors && pnpm build` | ~2-4s |

| All packages | `pnpm build --filter "./packages/*"` | ~10-20s |

#### Rebuild Workflow

1. **Identify modified package**:

   ```bash
   # Example: Modified packages/data-manager/src/entities/Strategy.ts
   ```

2. **Rebuild the package**:

   ```bash
   cd packages/data-manager && pnpm build
   ```

3. **Rebuild dependent packages** (if needed):

   ```bash
   # If core depends on data-manager and was using the modified code
   cd packages/core && pnpm build
   ```

4. **Rebuild web application to verify**:

   ```bash
   # ALWAYS rebuild web to ensure everything works
   cd apps/web && pnpm build
   ```

5. **Verify build success**:

   ```bash
   # Check for build errors
   # Ensure no TypeScript compilation errors
   # Confirm web build completes successfully
   ```

#### AI Agent Instructions for Package Builds

1. **ALWAYS rebuild** after modifying package source files
2. **Build in dependency order** (dependencies first, then dependents)
3. **ALWAYS rebuild web application** after package changes to verify integration
4. **Report build status** to the user at each step
5. **If build fails**:
   - Report the exact error
   - Attempt to fix the issue
   - Rebuild after fixing
6. **Batch builds** when modifying multiple packages
7. **Never skip web build** - it's the final verification step

#### Example Workflow

```bash
# Scenario: Modified Strategy entity and StrategyRepository

# Step 1: Identify modified package
echo "Modified: packages/data-manager/src/entities/Strategy.ts"
echo "Modified: packages/data-manager/src/repositories/StrategyRepository.ts"

# Step 2: Rebuild data-manager
cd packages/data-manager
pnpm build

# Step 3: Rebuild dependent packages if needed
# If core/strategies import from data-manager, rebuild them too
cd ../core
pnpm build

# Step 4: ALWAYS rebuild web to verify everything works
cd ../../apps/web
pnpm build

# Step 5: Verify no errors
echo "‚úÖ All packages rebuilt successfully"
echo "‚úÖ Web application build verified"
```

#### Build Optimization

- **Incremental builds**: TypeScript only rebuilds changed files
- **Parallel builds**: Use `pnpm -r --parallel build` for multiple packages
- **Skip if no TypeScript changes**: Don't rebuild for doc-only changes

#### Skip Conditions

Rebuild may be skipped ONLY when:

- Only modifying `.md` documentation files
- Only modifying test files (`*.test.ts`, `*.spec.ts`) in non-published packages
- Only modifying configuration files (`.json`, `.yml`) that don't affect build output
- User explicitly requests to skip rebuild (rare)

#### Common Build Errors and Solutions

| Error | Cause | Solution |
|-------|-------|----------|
| `Cannot find module` | Package not rebuilt | Rebuild the dependency |
| `Type error` | Outdated type definitions | Rebuild packages in order |
| `Circular dependency` | Import cycle | Check and fix imports |
| `Out of memory` | Large build | Increase Node memory |

#### Performance Considerations

- Average single package build: **2-5 seconds**
- Average multi-package build: **10-20 seconds**
- Full monorepo build: **30-60 seconds**
- **Web application build: 3-5 seconds**

**Total time for typical workflow:**

- Single package + web: **5-10 seconds**
- Multiple packages + web: **15-25 seconds**
- Full rebuild + web: **35-65 seconds**

**Always rebuild to avoid runtime errors and type mismatches!**

### Quick Reference

```bash
# Standard workflow (RECOMMENDED)
# 1. Rebuild modified package
cd packages/{package-name} && pnpm build

# 2. Rebuild dependent packages (if any)
cd ../dependent-package && pnpm build

# 3. ALWAYS rebuild web to verify
cd ../../apps/web && pnpm build

# ---

# Alternative: Multiple packages (if interdependent)
cd packages/data-manager && pnpm build && \
cd ../core && pnpm build && \
cd ../strategies && pnpm build && \
cd ../../apps/web && pnpm build

# Alternative: All packages + web at once
pnpm build --filter "./packages/*" && \
cd apps/web && pnpm build

# Alternative: Parallel (faster but harder to debug)
pnpm -r --parallel --filter "./packages/*" build && \
cd apps/web && pnpm build
```

**Critical Rule**: ALWAYS finish with `cd apps/web && pnpm build` to verify integration! üèóÔ∏è‚úÖ

---

## üóÑÔ∏è Database Schema Synchronization Rules

### When to Sync Database Schema

**After ANY modification to database entity definitions under `packages/data-manager/src/entities/`, AI agents MUST synchronize the database schema.**

#### Core Principle

> **"Entity Modified ‚Üí Schema Synced ‚Üí Verified"**
>
> When modifying TypeORM entities, AI agents MUST:
>
> 1. ‚úÖ **Modify the entity** (e.g., add fields, update enums)
> 2. ‚úÖ **Rebuild the data-manager package**
> 3. ‚úÖ **Run schema sync** to update the database
> 4. ‚úÖ **Verify the change** works in the application

#### When Schema Sync is REQUIRED

Schema synchronization is MANDATORY when:

1. **Adding/Modifying Entity Fields**
   - Adding new columns to entities
   - Changing column types or constraints
   - Adding/removing indexes
   - Modifying relationships (foreign keys)

2. **Enum Changes**
   - Adding new enum values (e.g., `StrategyType`, `StrategyStatus`)
   - Removing enum values (caution: may break existing data)
   - Renaming enum values

3. **New Entities**
   - Creating new entity classes
   - New tables that need to be created

4. **Entity Refactoring**
   - Renaming entities (creates new table)
   - Splitting/merging entities

#### Schema Sync Command

```bash
cd packages/data-manager && pnpm run sync-schema
```

**What this does:**
- Connects to the PostgreSQL database
- Compares current schema with entity definitions
- Creates/updates tables automatically
- Adds/updates all indexes
- Updates enum types
- Creates foreign key relationships
- Updates the query-result-cache table

#### Complete Workflow

```bash
# Step 1: Modify entity (e.g., add new enum value to Strategy.ts)
# Edit: packages/data-manager/src/entities/Strategy.ts
# Added: MOVING_WINDOW_GRIDS = 'moving_window_grids' to StrategyType enum

# Step 2: Rebuild data-manager package
cd packages/data-manager
pnpm build

# Step 3: Sync database schema
pnpm run sync-schema

# Step 4: Verify in application
# Test that the new enum value works via API/UI

# Step 5: Rebuild web application
cd ../../apps/web
pnpm build
```

#### AI Agent Instructions for Schema Sync

1. **ALWAYS sync schema** after modifying entities
2. **NEVER skip this step** - database will be out of sync with code
3. **ALWAYS verify** the sync completed successfully
4. **Check for errors** in the sync output
5. **Report sync status** to the user

#### Common Scenarios

**Adding a New Strategy Type:**

```typescript
// 1. Add to StrategyType enum in Strategy.ts
export enum StrategyType {
  MOVING_AVERAGE = 'moving_average',
  RSI = 'rsi',
  NEW_STRATEGY = 'new_strategy', // Added
}

// 2. Run sync-schema
// cd packages/data-manager && pnpm run sync-schema

// 3. Verify it works
// Try creating a strategy with type='new_strategy'
```

**Adding a New Entity Field:**

```typescript
// 1. Add field to entity
@Column({ type: 'text', nullable: true })
newField?: string;

// 2. Rebuild package
// cd packages/data-manager && pnpm build

// 3. Sync schema
// pnpm run sync-schema
```

#### Error Handling

**If sync-schema fails:**

1. **Check database connection**
   - Verify PostgreSQL is running
   - Check `.env` file has correct credentials
   - Ensure database exists

2. **Check for syntax errors**
   - Verify entity decorators are correct
   - Check enum syntax
   - Validate column types

3. **Check for conflicts**
   - Existing data may conflict with new constraints
   - Manual migration may be needed for complex changes

#### Skip Conditions

Schema sync may be skipped ONLY when:

- Only modifying repository logic (no entity changes)
- Only modifying non-entity TypeScript files
- Only updating documentation
- User explicitly requests to skip (rare, not recommended)

**Default behavior: ALWAYS sync schema after entity modifications.**

#### Production Considerations

**For production environments:**
- Consider using TypeORM migrations instead of automatic sync
- Test schema changes in development first
- Backup database before major schema changes
- Document all schema modifications

#### Quick Reference

```bash
# Standard workflow after entity modification
cd packages/data-manager
pnpm build
pnpm run sync-schema

# Verify database updated
# Check application works with new schema

# Rebuild web if needed
cd ../../apps/web
pnpm build
```

**Critical Rule**: ALWAYS run `pnpm run sync-schema` after modifying entity definitions! üóÑÔ∏è‚úÖ

---

## üîí Database and File I/O Performance & Security Rules

### Mandatory Performance and Security Considerations

**When working with database queries or file I/O operations, AI agents MUST carefully consider performance implications and security risks BEFORE implementing.**

#### Core Principle

> **"Measure Twice, Query Once - Think Security First"**
>
> When implementing ANY database or file operations, AI agents MUST:
>
> 1. ‚úÖ **Analyze query patterns** - Avoid N+1 queries
> 2. ‚úÖ **Consider data volume** - Will this scale with 10x, 100x data?
> 3. ‚úÖ **Validate inputs** - Prevent SQL injection and path traversal
> 4. ‚úÖ **Use parameterized queries** - Never concatenate user input into SQL
> 5. ‚úÖ **Check permissions** - Verify user authorization before data access
> 6. ‚úÖ **Add indexes** - Ensure queries use appropriate database indexes
> 7. ‚úÖ **Limit results** - Use pagination for large datasets

---

### üö´ Common Anti-Patterns to AVOID

#### ‚ùå **1. N+1 Query Problem**

**BAD - Separate query for each item:**
```typescript
// ‚ùå NEVER DO THIS: N+1 queries
const strategies = await getStrategies(); // 1 query
for (const strategy of strategies) {
  const orders = await getOrders(strategy.id); // N queries
  // = 1 + N total queries!
}
```

**GOOD - Single query with JOIN or IN clause:**
```typescript
// ‚úÖ DO THIS: 1 query for all data
const strategies = await getStrategies(); // 1 query
const strategyIds = strategies.map(s => s.id);
const allOrders = await getOrdersForStrategies(strategyIds); // 1 query
const ordersByStrategy = groupBy(allOrders, 'strategyId'); // Group in memory
// = 2 total queries (constant time)
```

#### ‚ùå **2. Missing Indexes**

**BAD - Query without index:**
```typescript
// ‚ùå Slow: Full table scan
const orders = await repository.find({
  where: { customerId: userId }, // No index on customerId
});
```

**GOOD - Add index for frequently queried columns:**
```typescript
// ‚úÖ In entity definition:
@Entity()
class Order {
  @Index() // Add index
  @Column()
  customerId: string;
}
```

#### ‚ùå **3. SQL Injection Vulnerability**

**BAD - String concatenation:**
```typescript
// ‚ùå NEVER DO THIS: SQL injection risk!
const query = `SELECT * FROM users WHERE email = '${userEmail}'`;
await db.query(query);
```

**GOOD - Parameterized queries:**
```typescript
// ‚úÖ DO THIS: Safe parameterized query
const query = 'SELECT * FROM users WHERE email = ?';
await db.query(query, [userEmail]);
// OR using query builder:
await repository.findOne({ where: { email: userEmail } });
```

#### ‚ùå **4. Loading Too Much Data**

**BAD - No pagination:**
```typescript
// ‚ùå Loads entire table into memory!
const allOrders = await repository.find();
```

**GOOD - Pagination:**
```typescript
// ‚úÖ DO THIS: Paginate results
const orders = await repository.find({
  skip: (page - 1) * pageSize,
  take: pageSize,
  order: { createdAt: 'DESC' },
});
```

#### ‚ùå **5. Missing Authorization Checks**

**BAD - No permission check:**
```typescript
// ‚ùå Any user can access any strategy!
const strategy = await repository.findOne({ where: { id } });
```

**GOOD - Check ownership:**
```typescript
// ‚úÖ DO THIS: Verify user owns the resource
const strategy = await repository.findOne({
  where: { id, userId: currentUser.id },
});
if (!strategy) {
  throw new UnauthorizedException('Access denied');
}
```

#### ‚ùå **6. Path Traversal in File Operations**

**BAD - Unsanitized file paths:**
```typescript
// ‚ùå NEVER DO THIS: Path traversal vulnerability!
const filePath = `/uploads/${userProvidedFilename}`;
fs.readFile(filePath); // User could provide: ../../../../etc/passwd
```

**GOOD - Validate and sanitize:**
```typescript
// ‚úÖ DO THIS: Sanitize filename
import path from 'path';
const safeFilename = path.basename(userProvidedFilename); // Remove path components
const filePath = path.join(UPLOAD_DIR, safeFilename);
if (!filePath.startsWith(UPLOAD_DIR)) {
  throw new Error('Invalid file path');
}
```

---

### ‚úÖ Required Performance Analysis

**Before implementing database operations, AI agents MUST:**

1. **Estimate data volume:**
   - "Will this strategy have 10 orders or 10,000 orders?"
   - "Will this user have 1 file or 1,000 files?"

2. **Count queries:**
   - "How many database queries will this make?"
   - "Does query count grow with data (O(N)) or stay constant (O(1))?"

3. **Check for loops:**
   - "Am I querying inside a loop?" ‚Üí ‚ùå N+1 problem!
   - "Can I fetch all data in one query?" ‚Üí ‚úÖ Better!

4. **Consider caching:**
   - "Is this data rarely changed?" ‚Üí Consider caching
   - "Is this query expensive?" ‚Üí Cache the result

---

### ‚úÖ Required Security Checks

**Before implementing data access, AI agents MUST:**

1. **‚úÖ Input Validation:**
   - Validate ALL user inputs
   - Check data types (string, number, email, etc.)
   - Enforce length limits
   - Reject malicious patterns (../,  <script>, etc.)

2. **‚úÖ Parameterized Queries:**
   - NEVER concatenate user input into SQL
   - ALWAYS use query builder or parameterized queries
   - Use ORM methods (find, findOne, etc.)

3. **‚úÖ Authorization:**
   - Check user owns the resource
   - Verify permissions before read/write/delete
   - Filter queries by userId/tenantId

4. **‚úÖ File Path Safety:**
   - Use `path.basename()` to remove directory components
   - Validate file path stays within allowed directory
   - Check file extension whitelist

5. **‚úÖ Rate Limiting:**
   - Implement rate limits for expensive operations
   - Prevent DoS attacks via excessive queries

---

### üîç AI Agent Checklist for Database Operations

Before writing database code, verify:

- [ ] **Query pattern analyzed** - No N+1 queries
- [ ] **Indexes present** - Columns in WHERE clause are indexed
- [ ] **Data volume considered** - Works with 10x, 100x, 1000x data
- [ ] **Inputs validated** - All user inputs are validated
- [ ] **Parameterized queries** - No string concatenation
- [ ] **Authorization checked** - User can access this data
- [ ] **Pagination implemented** - Large datasets are paginated
- [ ] **Transactions used** - Multiple writes use transactions
- [ ] **Error handling** - Database errors handled gracefully
- [ ] **Performance tested** - Query performance verified

---

### üîç AI Agent Checklist for File I/O Operations

Before writing file operations, verify:

- [ ] **Path sanitized** - Use `path.basename()` and validate
- [ ] **Directory validated** - Path stays within allowed directory
- [ ] **Extension checked** - File extension is whitelisted
- [ ] **Size limited** - File size is within allowed limit
- [ ] **Permissions checked** - User authorized to access file
- [ ] **Error handling** - File not found, permission denied handled
- [ ] **Resource cleanup** - File handles closed properly
- [ ] **Async operations** - Use async file operations (don't block)
- [ ] **Concurrent access** - Handle file locks if needed

---

### üìä Performance Analysis Example

**Scenario: Fetch PnL for all strategies**

**‚ùå BAD Implementation (N+1):**
```typescript
// Get all strategies
const strategies = await strategyRepo.find(); // 1 query

// For each strategy, get orders
for (const strategy of strategies) {
  const orders = await orderRepo.find({
    where: { strategyId: strategy.id } // N queries
  });
  calculatePnL(orders);
}
// Total: 1 + N queries
// 10 strategies = 11 queries
// 100 strategies = 101 queries ‚ùå SLOW!
```

**‚úÖ GOOD Implementation (Optimized):**
```typescript
// Get all strategies
const strategies = await strategyRepo.find(); // 1 query

// Get ALL orders in ONE query
const strategyIds = strategies.map(s => s.id);
const allOrders = await orderRepo.find({
  where: { strategyId: In(strategyIds) } // 1 query with IN clause
});

// Group in memory (fast)
const ordersByStrategy = new Map();
for (const order of allOrders) {
  if (!ordersByStrategy.has(order.strategyId)) {
    ordersByStrategy.set(order.strategyId, []);
  }
  ordersByStrategy.get(order.strategyId).push(order);
}

// Calculate PnL using pre-fetched data
for (const strategy of strategies) {
  const orders = ordersByStrategy.get(strategy.id) || [];
  calculatePnL(orders);
}
// Total: 2 queries (constant)
// 10 strategies = 2 queries ‚úÖ FAST!
// 100 strategies = 2 queries ‚úÖ FAST!
```

---

### üõ°Ô∏è Security Analysis Example

**Scenario: Download user's uploaded file**

**‚ùå BAD Implementation (Path Traversal):**
```typescript
// ‚ùå VULNERABLE!
app.get('/download/:filename', async (req, res) => {
  const filename = req.params.filename; // User input
  const filePath = `/uploads/${filename}`; // ‚ùå Dangerous!
  res.sendFile(filePath);
  // User can request: ../../../../etc/passwd
});
```

**‚úÖ GOOD Implementation (Safe):**
```typescript
// ‚úÖ SECURE!
app.get('/download/:filename', async (req, res) => {
  const filename = req.params.filename;
  
  // 1. Sanitize filename (remove path components)
  const safeFilename = path.basename(filename);
  
  // 2. Build safe path
  const filePath = path.resolve(UPLOAD_DIR, safeFilename);
  
  // 3. Verify path is within allowed directory
  if (!filePath.startsWith(UPLOAD_DIR)) {
    return res.status(400).json({ error: 'Invalid file path' });
  }
  
  // 4. Check file exists and user owns it
  const file = await fileRepo.findOne({
    where: { 
      filename: safeFilename,
      userId: req.user.id // ‚úÖ Authorization check
    }
  });
  
  if (!file) {
    return res.status(404).json({ error: 'File not found' });
  }
  
  // 5. Send file
  res.sendFile(filePath);
});
```

---

### ‚ö° Quick Reference: Query Optimization

| Pattern | Queries | Performance | Use When |
|---------|---------|-------------|----------|
| **Fetch in loop** | O(N) | ‚ùå Slow | Never |
| **IN clause** | O(1) | ‚úÖ Fast | < 1000 IDs |
| **JOIN** | O(1) | ‚úÖ Fast | Always prefer |
| **Subquery** | O(1) | ‚úÖ Fast | Complex filters |
| **Full table scan** | O(1) | ‚ùå Slow | Add index! |

---

### üîê Quick Reference: Security Checklist

| Risk | Mitigation | Example |
|------|------------|---------|
| **SQL Injection** | Parameterized queries | `where: { id: userId }` |
| **Path Traversal** | Sanitize paths | `path.basename(filename)` |
| **Unauthorized Access** | Check ownership | `where: { userId }` |
| **XSS** | Sanitize output | Use React (auto-escapes) |
| **DoS** | Rate limiting | Max 100 req/min |
| **File Upload Abuse** | Size + type limits | Max 10MB, images only |

---

### üìù AI Agent Responsibilities

**The AI agent MUST:**

1. ‚úÖ **Analyze BEFORE coding** - Think about performance first
2. ‚úÖ **Ask if uncertain** - "Will this query be slow with 10,000 records?"
3. ‚úÖ **Propose optimizations** - Suggest better approaches
4. ‚úÖ **Add comments** - Explain why approach is chosen
5. ‚úÖ **Test performance** - Verify query speed with realistic data
6. ‚úÖ **Document security** - Note security considerations
7. ‚úÖ **Review existing code** - Identify and fix performance issues

**The AI agent MUST NOT:**

1. ‚ùå **Query in loops** - Without considering N+1 problem
2. ‚ùå **Skip validation** - All user input must be validated
3. ‚ùå **Assume small data** - Always design for scale
4. ‚ùå **Concatenate SQL** - Use parameterized queries
5. ‚ùå **Skip authorization** - Always check permissions
6. ‚ùå **Ignore errors** - Handle database/file errors gracefully

---

### Summary: Performance and Security are NOT Optional

> **Every database query and file operation MUST be analyzed for performance implications and security risks. If unsure, ASK before implementing. It's better to be slow and correct than fast and vulnerable.**

**Critical Rules:**

1. **NEVER query in a loop** - Fetch all data in one query
2. **ALWAYS validate user input** - Prevent injection attacks
3. **ALWAYS check authorization** - Verify user can access data
4. **ALWAYS use parameterized queries** - Never concatenate SQL
5. **ALWAYS sanitize file paths** - Prevent path traversal
6. **ALWAYS consider scale** - Design for 100x data growth
7. **ALWAYS add indexes** - For columns in WHERE clauses

**Remember**: Security vulnerabilities and performance issues are often introduced at the design stage, not the implementation stage. Think carefully BEFORE coding! üîí‚ö°

---

## üß™ Verification and Testing Rules

### Mandatory Verification After Changes

**AI agents MUST verify that their modifications work correctly before considering a task complete. The agent is responsible for identifying and resolving issues independently.**

#### Core Principle

> **"Modify ‚Üí Verify ‚Üí Resolve Issues Independently"**
>
> When making ANY code modifications, AI agents MUST:
>
> 1. ‚úÖ **Make the modification**
> 2. ‚úÖ **Verify it works correctly** through appropriate testing
> 3. ‚úÖ **Identify any issues** through testing/logs
> 4. ‚úÖ **Resolve all issues independently** without requiring user intervention
> 5. ‚úÖ **Re-verify** after fixes until everything works
>
> **NEVER mark a task as complete without verification. NEVER leave issues unresolved.**

#### When Verification is REQUIRED

Verification is MANDATORY for:

1. **WebSocket/Network Changes**
   - Exchange connector modifications
   - Subscription/unsubscription logic
   - Real-time data streams
   - API endpoint changes

2. **Core Logic Changes**
   - Trading engine modifications
   - Strategy implementations
   - Order management
   - Risk management

3. **Data Processing Changes**
   - Data normalization/transformation
   - Event handling
   - Message parsing
   - Symbol mapping

4. **UI/Frontend Changes**
   - Component behavior
   - Real-time data display
   - User interactions
   - State management

5. **Database/Persistence Changes**
   - Entity modifications
   - Repository updates
   - Migration scripts
   - Data queries

#### Verification Methods

**1. For Backend/Console Applications:**

```bash
# Run the application and verify behavior
cd apps/console
pnpm dev
# OR use the debugger
# Debug console with ts-node (from launch.json)

# Check logs for:
# - ‚úÖ Successful connections
# - ‚úÖ Expected data flow
# - ‚úÖ No errors or warnings
# - ‚úÖ Correct behavior
```

**2. For WebSocket/Exchange Changes:**

```bash
# Create a test script if needed
# Example: test-binance-ws.js

# Run the test
node test-script.js

# Verify:
# - ‚úÖ Connection established
# - ‚úÖ Subscriptions confirmed
# - ‚úÖ Data received correctly
# - ‚úÖ Unsubscribe works
# - ‚úÖ No connection leaks
```

**3. For Web Application:**

```bash
# Build and run the web app
cd apps/web
pnpm build  # Must pass without errors
pnpm dev    # Verify in browser

# Check:
# - ‚úÖ No build errors
# - ‚úÖ UI renders correctly
# - ‚úÖ Real-time updates work
# - ‚úÖ No console errors
```

**4. For API/REST Endpoints:**

```bash
# Test with curl or similar
curl -X GET http://localhost:3000/api/endpoint

# Verify:
# - ‚úÖ Correct response status
# - ‚úÖ Expected data format
# - ‚úÖ No errors in logs
```

#### Issue Resolution Protocol

**When issues are found during verification:**

1. **IDENTIFY the root cause**
   - Read error messages carefully
   - Check logs for patterns
   - Understand the failure point
   - Trace through code flow

2. **ANALYZE the problem**
   - Is it a logic error?
   - Is it a configuration issue?
   - Is it a timing/async issue?
   - Is it a format/data mismatch?

3. **IMPLEMENT a fix**
   - Make targeted changes
   - Follow coding standards
   - Add logging if needed for debugging
   - Consider edge cases

4. **RE-VERIFY the fix**
   - Rebuild if necessary
   - Run the same verification test
   - Confirm the issue is resolved
   - Check for new issues introduced

5. **REPEAT until all issues are resolved**
   - Don't stop at the first fix
   - Verify comprehensively
   - Ensure stability
   - Clean up debug code if appropriate

#### AI Agent Responsibilities

**The AI agent MUST:**

1. ‚úÖ **Test every modification** before claiming completion
2. ‚úÖ **Verify the ORIGINAL issue is resolved** - Not just that the code compiles
3. ‚úÖ **Read and analyze logs** to identify issues
4. ‚úÖ **Resolve all issues independently** without asking the user to debug
5. ‚úÖ **Re-test after fixes** to confirm resolution
6. ‚úÖ **Add debug logging temporarily** if needed to diagnose issues
7. ‚úÖ **Remove temporary debug code** after verification (unless useful long-term)
8. ‚úÖ **Report test results** clearly to the user

**The AI agent MUST NOT:**

1. ‚ùå **Mark tasks complete without verification**
2. ‚ùå **Ask the user to test** unless explicitly requested
3. ‚ùå **Leave issues unresolved** for the user to fix
4. ‚ùå **Make blind changes** without understanding the problem
5. ‚ùå **Ignore error messages** or warnings in logs
6. ‚ùå **Skip verification** to save time
7. ‚ùå **Assume code works** without evidence

#### Verification Checklist

Before marking a task as complete, verify:

- [ ] **Code compiles** without errors (`pnpm build`)
- [ ] **Linting passes** without errors (`pnpm lint`)
- [ ] **Application runs** without crashes
- [ ] **Expected behavior works** as intended
- [ ] **No error messages** in logs during normal operation
- [ ] **Edge cases handled** appropriately
- [ ] **No regressions** introduced in existing functionality
- [ ] **Performance acceptable** (no obvious degradation)
- [ ] **Resource cleanup** (connections closed, memory freed)

#### Example Verification Workflow

```markdown
### Scenario: Modified Binance WebSocket subscription logic

**Step 1: Make the modification**
- Updated BinanceExchange.ts to use dynamic subscribe/unsubscribe
- Changed WebSocket URL format
- Modified message handling

**Step 2: Rebuild packages**
```bash
cd packages/exchange-connectors && pnpm build
cd ../core && pnpm build
```

**Step 3: Create test script**
```javascript
// test-binance-ws.js
const { BinanceExchange } = require('./dist/index.js');
// ... test subscription/unsubscription
```

**Step 4: Run test and observe**
```bash
node test-binance-ws.js
```

**Step 5: Analyze logs**
```
‚úÖ Binance WebSocket connected
‚úÖ Subscription confirmed
‚úÖ Ticker data received
‚úÖ Unsubscribe successful
‚úÖ TEST PASSED
```

**Step 6: Test in console app**
```bash
# Run console app with debugger
# Verify:
# - EventBus listeners receive data
# - No continuous logging after unsubscribe
# - No memory leaks
```

**Step 7: Fix any issues found**
- Added missing symbol mapping
- Fixed event type handling
- Corrected normalization logic

**Step 8: Re-verify**
- All tests pass
- No errors in logs
- Expected behavior confirmed

**Step 9: Clean up**
- Remove test script
- Remove excessive debug logging (keep useful logs)
- Report success to user
```

#### Time Expectations

Verification should be factored into task estimates:

- Simple changes: **+2-5 minutes** for verification
- Medium changes: **+5-15 minutes** for verification
- Complex changes: **+15-30 minutes** for verification
- Critical changes: **+30-60 minutes** for comprehensive testing

**Verification time is NOT optional. It is part of completing the task correctly.**

#### Continuous Verification During Development

For large/complex tasks:

1. **Verify incrementally** after each logical step
2. **Don't wait until the end** to test everything
3. **Catch issues early** when they're easier to fix
4. **Build confidence** that the approach is correct
5. **Adjust course** if verification reveals problems

#### Reporting to User

**Good reporting includes:**

```markdown
‚úÖ **VERIFICATION COMPLETE**

**Changes Made:**
- Modified BinanceExchange WebSocket handling
- Implemented dynamic subscribe/unsubscribe
- Updated message parsing

**Verification Performed:**
- ‚úÖ Built packages successfully
- ‚úÖ Created and ran test script
- ‚úÖ Verified subscription works
- ‚úÖ Verified unsubscription works
- ‚úÖ Tested in console app
- ‚úÖ Confirmed EventBus receives data
- ‚úÖ No errors in logs

**Issues Found & Resolved:**
1. Symbol mapping was missing ‚Üí Added symbolMap
2. Event format incorrect ‚Üí Updated handleWebSocketMessage
3. Unsubscribe not sending message ‚Üí Added UNSUBSCRIBE logic

**Final Status:**
All functionality verified and working correctly. ‚úÖ
```

**Bad reporting:**

```markdown
‚ùå I've made the changes. Please test it.
‚ùå The code should work now.
‚ùå I think this will fix the issue.
```

### Summary: Verification is Mandatory

> **Every modification MUST be verified. Every issue MUST be resolved. The ORIGINAL user request MUST be confirmed working. The AI agent is responsible for ensuring correctness, not the user.**

**Critical Rules:**

1. **Always verify the ORIGINAL issue** - If the user reported "push data callbacks not showing", verify that push data callbacks ARE now showing, not just that the code builds.
2. **Run the actual application** - Don't assume fixes work without running the real application the user will use.
3. **Check the user's perspective** - Verify from the user's point of view, not just the code's point of view.
4. **Complete the full loop** - Make change ‚Üí Build ‚Üí Run ‚Üí Verify user's original problem is solved.

**Remember**: Untested code is broken code. Verification is not optional‚Äîit's a fundamental part of professional software development. üß™‚úÖ

---

## üß™ Test Execution Rules

### Mandatory Test Execution

**AI agents MUST execute all test files/cases that were written or modified during the task.**

#### When to Execute Tests

Tests MUST be executed when:

1. **New test files are created** - Run the new test immediately after creation
2. **Test files are modified** - Re-run the modified test to verify changes
3. **Source code is modified** - Run related tests to verify no regressions
4. **Completing a task** - Run all relevant tests before marking complete

#### Test Execution Protocol

**For Exchange Connector Tests:**

```bash
# After writing/modifying WebSocket tests
npm run test:binance        # Binance WebSocket test
npm run test:okx            # OKX WebSocket test
npm run test:coinbase       # Coinbase WebSocket test

# After writing/modifying REST API tests
npm run test:binance-rest   # Binance REST API test
npm run test:okx-rest       # OKX REST API test
npm run test:coinbase-rest  # Coinbase REST API test

# Run all tests
npm run test:all-exchanges  # Complete test suite
```

**For Other Tests:**

- Execute using appropriate test command
- Verify exit codes (0 = pass, non-zero = fail)
- Review test output for failures

#### Test Execution Requirements

1. ‚úÖ **Execute IMMEDIATELY after writing** - Don't wait for user to ask
2. ‚úÖ **Verify test passes** - Check exit code and output
3. ‚úÖ **Fix failures before proceeding** - Never leave failing tests
4. ‚úÖ **Report results to user** - Show pass/fail summary
5. ‚úÖ **Document any known limitations** - E.g., "Requires credentials"

#### Handling Test Failures

**When tests fail:**

1. **Read the error output carefully**
2. **Identify the root cause** (not just symptoms)
3. **Fix the issue** in source or test code
4. **Rebuild if necessary** (`pnpm build`)
5. **Re-run the test** to verify fix
6. **Repeat until all tests pass**

#### Known Test Limitations

**Document and accept these limitations:**

- **Coinbase REST API** - Requires authentication for all endpoints (public + private)
- **User Data Tests** - Require API credentials in `.env` file
- **Network Tests** - May fail due to rate limits or network issues

#### Example Test Execution Workflow

```markdown
**Step 1: Write test file**
- Created `test-binance-rest.ts`

**Step 2: Verify types**
```bash
npx tsc --noEmit src/tests/test-binance-rest.ts
‚úÖ Types pass
```

**Step 3: Execute test**
```bash
npm run test:binance-rest
‚úÖ 9/9 tests passed (0.9s)
```

**Step 4: Report to user**
‚úÖ Binance REST API test created and verified!
- All market data endpoints working
- Account endpoints require credentials
- Test completes in <1 second
```

#### AI Agent Test Execution Responsibilities

**The AI agent MUST:**

1. ‚úÖ **Execute ALL new/modified tests** before task completion
2. ‚úÖ **Verify tests pass** (or document known failures)
3. ‚úÖ **Fix any test failures** before marking task complete
4. ‚úÖ **Report test results** clearly to user
5. ‚úÖ **Document test coverage** for the implementation

**The AI agent MUST NOT:**

1. ‚ùå **Skip test execution** to save time
2. ‚ùå **Mark tasks complete** without running tests
3. ‚ùå **Leave failing tests** for the user to fix
4. ‚ùå **Create tests without executing them**

### Summary: Test Execution is Mandatory

> **Every test written MUST be executed. Every test modified MUST be re-run. Test failures MUST be fixed. The AI agent is responsible for ensuring tests pass, not the user.**

**Critical Rule**: If you write a test, you MUST run it immediately and verify it passes! üß™‚úÖ

---

## üöÄ Running Console Application (main.ts)

### Mandatory Execution Method

**When running `apps/console/src/main.ts` for testing or verification, AI agents MUST use the same settings as configured in `.vscode/launch.json` debugger configuration.**

#### Required Execution Command

```bash
cd apps/console && \
NODE_ENV=development \
TS_NODE_PROJECT=tsconfig.build.json \
TS_NODE_FILES=true \
NODE_OPTIONS="--conditions=source" \
node -r ts-node/register \
     -r tsconfig-paths/register \
     -r reflect-metadata \
     src/main.ts
```

#### Why These Settings?

1. **`ts-node/register`** - Enables TypeScript execution without pre-compilation
2. **`tsconfig-paths/register`** - Resolves `@itrade/*` path aliases correctly
3. **`reflect-metadata`** - Required for TypeORM decorators
4. **`TS_NODE_PROJECT=tsconfig.build.json`** - Uses the correct TypeScript configuration
5. **`NODE_OPTIONS="--conditions=source"`** - Ensures source maps work correctly

#### When to Run main.ts

Run `main.ts` when:

1. **Verifying TradingEngine integration** after exchange connector changes
2. **Testing user data subscriptions** for all exchanges
3. **Verifying strategy subscriptions** work correctly
4. **Checking EventBus emissions** from exchanges
5. **Validating database connectivity** and entity persistence
6. **Testing graceful shutdown** and cleanup

#### Running with Timeout

For automated testing (non-interactive):

```bash
cd apps/console && \
(NODE_ENV=development \
 TS_NODE_PROJECT=tsconfig.build.json \
 TS_NODE_FILES=true \
 NODE_OPTIONS="--conditions=source" \
 node -r ts-node/register \
      -r tsconfig-paths/register \
      -r reflect-metadata \
      src/main.ts 2>&1 & PID=$!; \
 sleep 15; \
 kill $PID 2>/dev/null; \
 wait $PID 2>/dev/null) | grep -E "‚úÖ|üì°|üîç|Balance|Position|Order"
```

#### Expected Output

When running successfully, you should see:

- ‚úÖ Database connected
- ‚úÖ Exchange(s) initialized (Binance, OKX, Coinbase)
- ‚úÖ Subscribed to user data for each exchange
- üìä Position/Balance/Order updates (if available)
- üöÄ Trading System is LIVE

#### Known Issues

- **Binance 401 Unauthorized**: API key permissions or IP whitelisting issue (external config, not code bug)
- **OKX Invalid Timestamp**: Incorrect timestamp format (should be fixed in code)
- **Coinbase 401 Unauthorized**: Requires valid credentials for REST API (WebSocket public data doesn't require auth)
- **TypeORM Decorator Error**: Packages need to be rebuilt (`pnpm build --filter "./packages/*"`)

#### Critical Rules

1. ‚ùå **NEVER use `npm run dev`** - It uses `tsx` which has different module resolution
2. ‚ùå **NEVER use `tsx src/main.ts`** - It bypasses required registrations
3. ‚úÖ **ALWAYS use the command above** - It matches the debugger configuration
4. ‚úÖ **ALWAYS rebuild packages first** if you get "Cannot find module" errors
5. ‚úÖ **ALWAYS verify exchanges connect** and user data subscriptions work

### Summary: Use Debugger Settings for main.ts

> **When running `main.ts`, ALWAYS use the exact same settings as `.vscode/launch.json` to ensure consistent behavior between AI testing and user debugging.**

---

## üîç TypeScript Code Quality Verification Rules

### Mandatory Verification After TypeScript Code Changes

**When ANY TypeScript code (.ts, .tsx files) in a package is modified, added, or deleted, AI agents MUST execute the following verification steps:**

#### Core Principle

> **"Code Modified ‚Üí Lint & TypeCheck ‚Üí Verify Applications"**
>
> After modifying TypeScript code in any package:
>
> 1. ‚úÖ **Verify the modified package** - Run lint and typecheck in the current package
> 2. ‚úÖ **Verify dependent applications** - Run lint and typecheck in `apps/web` and `apps/console`
> 3. ‚úÖ **Fix all errors** before marking task complete
> 4. ‚úÖ **Never skip verification** - Type safety is critical

#### When Verification is REQUIRED

Verification is MANDATORY when modifying:

1. **Package Source Files** (`packages/*/src/**/*.ts`, `*.tsx`)
   - Entity definitions
   - Type definitions
   - Repository files
   - Service implementations
   - Utility functions
   - Any exported modules

2. **Application Source Files** (`apps/*/src/**/*.ts`, `*.tsx`)
   - Components
   - Pages
   - API routes
   - Server code
   - Client code

#### Verification Commands

**For Modified Package:**

```bash
# Step 1: Navigate to the modified package
cd packages/{package-name}

# Step 2: Run lint
pnpm lint

# Step 3: Run typecheck
pnpm typecheck

# Step 4: Fix any errors
pnpm lint --fix  # Auto-fix lint issues
# Then manually fix any remaining typecheck errors
```

**For Dependent Applications (ALWAYS):**

```bash
# Step 1: Verify web application
cd apps/web
pnpm lint
pnpm typecheck

# Step 2: Verify console application
cd apps/console
pnpm lint
pnpm typecheck
```

#### Complete Verification Workflow

```bash
# Example: After modifying packages/core/src/types/index.ts

# 1. Verify the modified package
cd packages/core
pnpm lint
pnpm typecheck

# 2. If errors found, fix them
pnpm lint --fix
# Fix typecheck errors manually

# 3. Rebuild the package (critical for type propagation)
pnpm build

# 4. Verify web application
cd ../../apps/web
pnpm lint
pnpm typecheck

# 5. Verify console application
cd ../console
pnpm lint
pnpm typecheck

# 6. If web/console have errors, fix them
# This ensures the package changes integrate correctly
```

#### AI Agent Responsibilities

**The AI agent MUST:**

1. ‚úÖ **Run lint and typecheck** on the modified package immediately after changes
2. ‚úÖ **Run lint and typecheck** on `apps/web` and `apps/console` after package changes
3. ‚úÖ **Rebuild the package** before verifying applications (for type propagation)
4. ‚úÖ **Fix all lint and typecheck errors** before completing the task
5. ‚úÖ **Report verification results** clearly to the user
6. ‚úÖ **Never skip verification** even if changes seem minor

**The AI agent MUST NOT:**

1. ‚ùå **Mark tasks complete** without running verification
2. ‚ùå **Skip application verification** after package changes
3. ‚ùå **Leave lint or typecheck errors** for the user to fix
4. ‚ùå **Assume changes are safe** without verification
5. ‚ùå **Skip rebuilding packages** before application verification

#### Verification Checklist

Before marking a TypeScript modification task as complete:

- [ ] **Modified package: lint passed** (`pnpm lint`)
- [ ] **Modified package: typecheck passed** (`pnpm typecheck`)
- [ ] **Modified package: rebuilt** (`pnpm build`)
- [ ] **Web app: lint passed** (`cd apps/web && pnpm lint`)
- [ ] **Web app: typecheck passed** (`cd apps/web && pnpm typecheck`)
- [ ] **Console app: lint passed** (`cd apps/console && pnpm lint`)
- [ ] **Console app: typecheck passed** (`cd apps/console && pnpm typecheck`)
- [ ] **All errors fixed** (no lint or typecheck errors remaining)

#### Quick Reference Commands

```bash
# Verify entire workspace (all packages and apps)
cd /path/to/iTrade
pnpm lint
pnpm typecheck

# These commands run sequentially through all workspace projects
# Errors will be displayed clearly for each package/app
```

#### Common Verification Scenarios

**Scenario 1: Modified a package entity/type**

```bash
# 1. Modified: packages/core/src/types/index.ts
cd packages/core
pnpm lint && pnpm typecheck && pnpm build

# 2. Verify apps use the updated types correctly
cd ../../apps/web && pnpm typecheck
cd ../console && pnpm typecheck
```

**Scenario 2: Modified a package service**

```bash
# 1. Modified: packages/exchange-connectors/src/binance/BinanceExchange.ts
cd packages/exchange-connectors
pnpm lint && pnpm typecheck && pnpm build

# 2. Verify apps integrate correctly
cd ../../apps/console && pnpm lint && pnpm typecheck
cd ../web && pnpm lint && pnpm typecheck
```

**Scenario 3: Modified multiple packages**

```bash
# 1. Verify each modified package
cd packages/core && pnpm lint && pnpm typecheck && pnpm build
cd ../data-manager && pnpm lint && pnpm typecheck && pnpm build

# 2. Verify both applications once at the end
cd ../../apps/web && pnpm lint && pnpm typecheck
cd ../console && pnpm lint && pnpm typecheck
```

#### Error Resolution Protocol

**When verification fails:**

1. **Read the error message carefully** - Understand what failed
2. **Identify the root cause** - Is it lint, typecheck, or integration?
3. **Fix the error** - Make necessary code changes
4. **Re-run verification** - Ensure the fix works
5. **Verify applications again** - Ensure integration still works
6. **Repeat until all pass** - Don't stop until everything is green

#### Skip Conditions

Verification may be skipped ONLY when:

- Only modifying `.md` documentation files
- Only modifying configuration files that don't affect types (`.json`, `.yml`)
- Only modifying test files that don't export types
- User explicitly requests to skip (rare, not recommended)

**Default behavior: ALWAYS verify TypeScript code changes.**

### Summary: TypeScript Verification is Mandatory

> **Every TypeScript code modification MUST be verified through lint and typecheck in both the modified package AND dependent applications (web/console). Type safety is non-negotiable.**

**Critical Rules:**

1. **Always run verification** after modifying TypeScript code
2. **Always verify applications** after package changes
3. **Always rebuild packages** before application verification
4. **Always fix all errors** before completing tasks
5. **Never skip verification** - Type errors cause runtime failures

**Remember**: Unverified TypeScript changes lead to runtime errors and integration issues. Verification is not optional‚Äîit's a fundamental part of professional TypeScript development. üîç‚úÖ

---

## üé® Frontend Development Conventions

### Mandatory Frontend Best Practices

**When working on frontend code (web or mobile applications), AI agents MUST follow these baseline conventions to ensure consistency, quality, and excellent user experience.**

#### Core Principle

> **"User First, Validate Everything, Optimize Performance"**
>
> When creating or modifying frontend code, AI agents MUST:
>
> 1. ‚úÖ **Validate all user inputs** (client and server side)
> 2. ‚úÖ **Use debouncing** for validation during user input
> 3. ‚úÖ **Provide clear error messages** that help users understand what's wrong
> 4. ‚úÖ **Implement loading states** for all async operations
> 5. ‚úÖ **Ensure accessibility** (keyboard navigation, screen readers, ARIA labels)
> 6. ‚úÖ **Follow security best practices** (sanitize inputs, protect API keys)
> 7. ‚úÖ **Write testable components** with proper TypeScript types

#### Frontend Development Checklist

**Before marking any frontend task complete, verify ALL of the following:**

- [ ] **All user inputs are validated** (client and server)
- [ ] **Validation uses debouncing** (500ms recommended)
- [ ] **Error messages are clear and helpful**
- [ ] **Forms have loading states during submission**
- [ ] **Submit buttons are disabled when form is invalid or submitting**
- [ ] **All inputs have proper labels** (no placeholder-only labels)
- [ ] **Interactive elements are keyboard accessible**
- [ ] **Focus indicators are visible**
- [ ] **Color contrast meets WCAG AA standards**
- [ ] **TypeScript types are properly defined** (no `any`)
- [ ] **Error boundaries are implemented**
- [ ] **Loading and error states are handled**
- [ ] **API keys are not exposed in frontend code**
- [ ] **User input is sanitized before display**
- [ ] **Components are tested with unit tests**
- [ ] **Code follows ESLint and Prettier conventions**

---

### 1. User Input Validation Rules

#### Required Validation Patterns

**Email Validation:**
```typescript
// ‚úÖ REQUIRED: Use debouncing and clear error messages
import { debounce } from 'lodash';
import { z } from 'zod';

const emailSchema = z.string().email('Please enter a valid email address');

const validateEmail = debounce((email: string, callback: (error: string | null) => void) => {
  try {
    emailSchema.parse(email);
    callback(null);
  } catch (error) {
    callback('Please enter a valid email address (e.g., user@example.com)');
  }
}, 500);
```

**Number Validation (Amount, Price, Quantity):**
```typescript
// ‚úÖ REQUIRED: Validate range and decimal precision
const validateAmount = debounce((
  value: string,
  min: number,
  max: number,
  decimals: number,
  callback: (error: string | null) => void
) => {
  if (!value.trim()) {
    callback(null);
    return;
  }
  
  const number = parseFloat(value);
  
  if (isNaN(number)) {
    callback('Please enter a valid number');
    return;
  }
  
  if (number < min) {
    callback(`Amount must be at least ${min}`);
    return;
  }
  
  if (number > max) {
    callback(`Amount must not exceed ${max}`);
    return;
  }
  
  const decimalPart = value.split('.')[1];
  if (decimalPart && decimalPart.length > decimals) {
    callback(`Maximum ${decimals} decimal places allowed`);
    return;
  }
  
  callback(null);
}, 500);
```

#### Validation Requirements

**The AI agent MUST:**

1. ‚úÖ **Always validate on both client AND server** - Never trust client-side validation alone
2. ‚úÖ **Use debouncing** (500ms recommended) for real-time validation during typing
3. ‚úÖ **Validate on blur** for individual fields
4. ‚úÖ **Validate on submit** for the entire form
5. ‚úÖ **Provide specific error messages** (not generic "Invalid input")
6. ‚úÖ **Use TypeScript types and Zod schemas** for type-safe validation

**The AI agent MUST NOT:**

1. ‚ùå **Validate on every keystroke** without debouncing (causes poor UX)
2. ‚ùå **Show error messages** before user finishes typing
3. ‚ùå **Use generic error messages** like "Error" or "Invalid"
4. ‚ùå **Allow form submission** with invalid data
5. ‚ùå **Skip server-side validation** (client-side can be bypassed)

---

### 2. Form Handling Rules

#### Required Form Implementation

```typescript
// ‚úÖ REQUIRED: Comprehensive form submission handling
const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  
  // 1. Validate all fields
  const errors = validateAllFields(formData);
  if (Object.keys(errors).length > 0) {
    setFormErrors(errors);
    return;
  }
  
  // 2. Disable submit button
  setIsSubmitting(true);
  
  try {
    // 3. Sanitize data before submission
    const sanitizedData = sanitizeFormData(formData);
    
    // 4. Submit to API
    const response = await fetch('/api/submit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(sanitizedData),
    });
    
    if (!response.ok) {
      throw new Error('Submission failed');
    }
    
    // 5. Show success message
    toast.success('Form submitted successfully');
    
    // 6. Reset form
    resetForm();
  } catch (error) {
    // 7. Show error message
    toast.error('Failed to submit form. Please try again.');
    console.error('Form submission error:', error);
  } finally {
    // 8. Re-enable submit button
    setIsSubmitting(false);
  }
};
```

#### Form Requirements

**The AI agent MUST:**

1. ‚úÖ **Show loading states** during submission (disable button, show spinner)
2. ‚úÖ **Prevent multiple submissions** (disable button when submitting)
3. ‚úÖ **Validate before submission** (don't send invalid data)
4. ‚úÖ **Handle errors gracefully** (show user-friendly messages)
5. ‚úÖ **Sanitize user input** before sending to server
6. ‚úÖ **Use react-hook-form + Zod** for complex forms (recommended)

---

### 3. Accessibility (a11y) Rules

#### Required Accessibility Practices

**The AI agent MUST:**

1. ‚úÖ **Use semantic HTML** (`<button>`, `<nav>`, `<main>`, `<article>`)
2. ‚úÖ **Provide alt text** for all images
3. ‚úÖ **Use proper heading hierarchy** (h1 ‚Üí h2 ‚Üí h3)
4. ‚úÖ **Make elements keyboard accessible** (Tab navigation works)
5. ‚úÖ **Provide visible focus indicators** for keyboard navigation
6. ‚úÖ **Use ARIA labels** when semantic HTML is insufficient
7. ‚úÖ **Ensure color contrast meets WCAG AA** (4.5:1 for normal text)
8. ‚úÖ **Support screen readers** with descriptive labels
9. ‚úÖ **Use proper labels for form inputs** (not placeholder-only)

**The AI agent MUST NOT:**

1. ‚ùå **Use `<div onClick>`** instead of `<button>`
2. ‚ùå **Rely on color alone** to convey information
3. ‚ùå **Remove focus outlines** without providing alternatives
4. ‚ùå **Use placeholder text as labels**
5. ‚ùå **Create keyboard traps**

#### Accessibility Example

```typescript
// ‚úÖ REQUIRED: Accessible form with proper labels and ARIA
<form onSubmit={handleSubmit}>
  <label htmlFor="email">
    Email Address
    <span className="text-red-500" aria-label="required">*</span>
  </label>
  <input
    id="email"
    type="email"
    value={email}
    onChange={handleEmailChange}
    aria-invalid={!!emailError}
    aria-describedby={emailError ? 'email-error' : undefined}
    required
  />
  {emailError && (
    <span id="email-error" role="alert" className="text-red-500">
      {emailError}
    </span>
  )}
</form>
```

---

### 4. Performance Optimization Rules

#### Required Performance Practices

**Debouncing and Throttling:**

```typescript
// ‚úÖ REQUIRED: Use debounce for validation, throttle for scroll
import { debounce, throttle } from 'lodash';

// Use DEBOUNCE for:
// - Search input (wait until user stops typing)
// - Form validation (wait until user finishes typing)
// - Auto-save (wait until user stops editing)
const debouncedSearch = debounce((query: string) => {
  searchAPI(query);
}, 500);

// Use THROTTLE for:
// - Scroll events (limit update frequency)
// - Resize events (limit recalculations)
// - Mouse move tracking (limit updates)
const throttledScroll = throttle(() => {
  updateScrollPosition();
}, 100);
```

**Component Optimization:**

```typescript
// ‚úÖ REQUIRED: Use memoization for expensive operations
import { memo, useMemo, useCallback } from 'react';

// Memoize expensive list components
const ExpensiveList = memo(({ items }: { items: Item[] }) => {
  return (
    <ul>
      {items.map(item => (
        <ExpensiveListItem key={item.id} item={item} />
      ))}
    </ul>
  );
});

// Use useMemo for expensive calculations
const sortedItems = useMemo(() => {
  return items.sort((a, b) => a.name.localeCompare(b.name));
}, [items]);

// Use useCallback for event handlers passed to children
const handleClick = useCallback((id: string) => {
  selectItem(id);
}, []);
```

**The AI agent MUST:**

1. ‚úÖ **Use debouncing** for validation and search (500ms recommended)
2. ‚úÖ **Use throttling** for scroll/resize events (100ms recommended)
3. ‚úÖ **Memoize expensive components** with `memo()`
4. ‚úÖ **Use useMemo** for expensive calculations
5. ‚úÖ **Use useCallback** for event handlers passed to children

---

### 5. Security Best Practices

#### Required Security Measures

**Input Sanitization:**

```typescript
// ‚úÖ REQUIRED: Sanitize user input before display
import DOMPurify from 'dompurify';

const sanitizeInput = (input: string): string => {
  return DOMPurify.sanitize(input, { ALLOWED_TAGS: [] });
};

const sanitizeHTML = (html: string): string => {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
    ALLOWED_ATTR: ['href', 'title'],
  });
};
```

**API Key Protection:**

```typescript
// ‚úÖ REQUIRED: Never expose API keys in frontend
// Use server-side API routes
const response = await fetch('/api/data', {
  method: 'GET',
  // No API key sent from frontend
});

// In Next.js API route:
export async function GET() {
  const apiKey = process.env.API_KEY; // Only accessible on server
  const data = await externalAPI.fetch({ apiKey });
  return Response.json(data);
}
```

**The AI agent MUST:**

1. ‚úÖ **Sanitize user input** before displaying or storing
2. ‚úÖ **Never expose API keys** in frontend code
3. ‚úÖ **Use server-side API routes** for sensitive operations
4. ‚úÖ **Validate and sanitize on server** (never trust client)
5. ‚úÖ **Use environment variables** for configuration
6. ‚úÖ **Escape user content** (React does this by default)

**The AI agent MUST NOT:**

1. ‚ùå **Hardcode API keys** in frontend code
2. ‚ùå **Trust client-side validation alone**
3. ‚ùå **Use `dangerouslySetInnerHTML`** without sanitization
4. ‚ùå **Store sensitive data** in localStorage/sessionStorage
5. ‚ùå **Expose internal API endpoints** publicly

---

### 6. UI/UX Best Practices

#### Required Loading States

```typescript
// ‚úÖ REQUIRED: Always show loading, error, and empty states
const DataTable = () => {
  const [data, setData] = useState<Item[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    fetchData()
      .then(setData)
      .catch(err => setError(err.message))
      .finally(() => setIsLoading(false));
  }, []);
  
  if (isLoading) {
    return <LoadingSpinner />;
  }
  
  if (error) {
    return <ErrorMessage message={error} onRetry={refetch} />;
  }
  
  if (data.length === 0) {
    return <EmptyState message="No data available" />;
  }
  
  return <Table data={data} />;
};
```

#### Required Button States

```typescript
// ‚úÖ REQUIRED: Show clear button states
<button
  onClick={handleSubmit}
  disabled={isSubmitting || hasErrors}
  className={cn(
    'btn-primary',
    isSubmitting && 'opacity-50 cursor-not-allowed'
  )}
>
  {isSubmitting ? (
    <>
      <Loader className="animate-spin" />
      Submitting...
    </>
  ) : (
    'Submit'
  )}
</button>
```

**The AI agent MUST:**

1. ‚úÖ **Show loading states** for all async operations
2. ‚úÖ **Show error states** with user-friendly messages
3. ‚úÖ **Show empty states** when no data is available
4. ‚úÖ **Disable buttons during submission** with visual feedback
5. ‚úÖ **Provide retry mechanisms** for failed operations
6. ‚úÖ **Use user-friendly error messages** (not raw error objects)

---

### 7. TypeScript Quality Rules

#### Required TypeScript Practices

```typescript
// ‚úÖ REQUIRED: Proper typing (no 'any')
interface User {
  id: string;
  email: string;
  name: string;
  role: 'admin' | 'user';
}

const fetchUser = async (userId: string): Promise<User> => {
  const response = await fetch(`/api/users/${userId}`);
  if (!response.ok) {
    throw new Error('Failed to fetch user');
  }
  return response.json();
};

const UserProfile = ({ userId }: { userId: string }) => {
  const [user, setUser] = useState<User | null>(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  if (!user) return <LoadingSpinner />;
  
  return <div>{user.name}</div>;
};
```

**The AI agent MUST:**

1. ‚úÖ **Define proper TypeScript interfaces** for all data structures
2. ‚úÖ **Avoid using `any`** - use proper types or `unknown` with type guards
3. ‚úÖ **Use type inference** where appropriate
4. ‚úÖ **Export types** that are used across files
5. ‚úÖ **Use union types** for states (e.g., `'idle' | 'loading' | 'error'`)

---

### 8. Testing Requirements

#### Required Testing Practices

```typescript
// ‚úÖ REQUIRED: Test user interactions and validation
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

describe('LoginForm', () => {
  it('validates email format', async () => {
    render(<LoginForm />);
    
    const emailInput = screen.getByLabelText('Email');
    await userEvent.type(emailInput, 'invalid-email');
    
    fireEvent.blur(emailInput);
    
    await waitFor(() => {
      expect(screen.getByText(/valid email/i)).toBeInTheDocument();
    });
  });
  
  it('disables submit button when form is invalid', () => {
    render(<LoginForm />);
    
    const submitButton = screen.getByRole('button', { name: /submit/i });
    expect(submitButton).toBeDisabled();
  });
});
```

**The AI agent MUST:**

1. ‚úÖ **Write tests for form validation**
2. ‚úÖ **Test user interactions** (clicks, typing, etc.)
3. ‚úÖ **Test error states** and error messages
4. ‚úÖ **Test loading states** and async operations
5. ‚úÖ **Use @testing-library/react** for component testing
6. ‚úÖ **Execute all tests** after writing or modifying them

---

### 9. Recommended Libraries

**For validation:**
- **Zod** - Schema validation with TypeScript inference (required)
- **Validator.js** - String validation utilities
- **libphonenumber-js** - Phone number validation

**For forms:**
- **react-hook-form** - Performant form library (recommended)
- **@hookform/resolvers** - Validation resolver for react-hook-form

**For utilities:**
- **lodash** - Debounce, throttle, and utility functions
- **date-fns** - Date manipulation and validation
- **DOMPurify** - HTML sanitization

**For UI/UX:**
- **react-hot-toast** - Toast notifications (lightweight)
- **sonner** - Toast notifications (alternative)
- **framer-motion** - Animations

**For testing:**
- **@testing-library/react** - Component testing
- **@testing-library/user-event** - User interaction simulation
- **vitest** - Fast test runner

---

### 10. Common Mistakes to Avoid

**The AI agent MUST AVOID:**

1. ‚ùå **No validation on client side** - Always validate before submission
2. ‚ùå **Validating too frequently** - Use debouncing for real-time validation
3. ‚ùå **Poor error messages** - Be specific about what's wrong and how to fix it
4. ‚ùå **No loading states** - Always show feedback during async operations
5. ‚ùå **Ignoring accessibility** - Use semantic HTML and ARIA labels
6. ‚ùå **Hardcoding values** - Use environment variables for configuration
7. ‚ùå **No error handling** - Always handle errors gracefully
8. ‚ùå **Using `any` in TypeScript** - Define proper types
9. ‚ùå **Exposing API keys** - Use server-side API routes
10. ‚ùå **Not testing components** - Write and execute tests

---

### Frontend Development Workflow

**Standard workflow for frontend tasks:**

1. ‚úÖ **Understand requirements** - What user interaction is needed?
2. ‚úÖ **Design component structure** - Plan state, props, and validation
3. ‚úÖ **Implement with TypeScript** - Use proper types from the start
4. ‚úÖ **Add validation** - Client-side (debounced) + server-side
5. ‚úÖ **Implement loading/error states** - Handle all async states
6. ‚úÖ **Ensure accessibility** - Semantic HTML, ARIA labels, keyboard navigation
7. ‚úÖ **Add tests** - Test validation, interactions, and error handling
8. ‚úÖ **Run linting** - `pnpm lint --fix`
9. ‚úÖ **Execute tests** - Verify all tests pass
10. ‚úÖ **Build and verify** - Test in browser (web) or simulator (mobile)

---

### AI Agent Frontend Responsibilities

**When working on frontend code, the AI agent MUST:**

1. ‚úÖ **Follow ALL items in the Frontend Development Checklist**
2. ‚úÖ **Validate user inputs with debouncing** (500ms recommended)
3. ‚úÖ **Provide clear, helpful error messages**
4. ‚úÖ **Implement loading states for all async operations**
5. ‚úÖ **Ensure keyboard accessibility** and screen reader support
6. ‚úÖ **Use proper TypeScript types** (no `any`)
7. ‚úÖ **Sanitize user input** before display or submission
8. ‚úÖ **Write and execute component tests**
9. ‚úÖ **Build and verify in browser/simulator** before completion
10. ‚úÖ **Follow ESLint and Prettier conventions**

**The AI agent MUST NOT:**

1. ‚ùå **Skip validation** - Always validate user inputs
2. ‚ùå **Use `any` in TypeScript** - Define proper types
3. ‚ùå **Expose API keys** in frontend code
4. ‚ùå **Skip loading/error states** - Always handle async states
5. ‚ùå **Ignore accessibility** - Make UI keyboard accessible
6. ‚ùå **Mark tasks complete** without testing in browser/simulator
7. ‚ùå **Leave linting errors** - Always run `pnpm lint --fix`
8. ‚ùå **Skip writing tests** - Test validation and user interactions

---

### Frontend Verification Checklist

**Before marking a frontend task complete, the AI agent MUST verify:**

#### Validation & Forms
- [ ] All user inputs have validation (client + server)
- [ ] Validation uses debouncing (500ms recommended)
- [ ] Error messages are clear and specific
- [ ] Forms show loading states during submission
- [ ] Submit buttons are disabled when invalid/submitting

#### Accessibility
- [ ] All inputs have proper labels (no placeholder-only)
- [ ] Interactive elements are keyboard accessible
- [ ] Focus indicators are visible
- [ ] Color contrast meets WCAG AA standards
- [ ] ARIA labels are used where appropriate

#### Code Quality
- [ ] TypeScript types are properly defined (no `any`)
- [ ] Error boundaries are implemented
- [ ] Loading and error states are handled
- [ ] User input is sanitized before display
- [ ] Code follows ESLint and Prettier conventions

#### Security
- [ ] API keys are not exposed in frontend code
- [ ] User input is validated on server side
- [ ] Sensitive operations use server-side API routes

#### Testing
- [ ] Components are tested with unit tests
- [ ] Tests cover validation logic
- [ ] Tests cover user interactions
- [ ] All tests pass when executed

#### Build & Verification
- [ ] Code builds without errors (`pnpm build`)
- [ ] Linting passes (`pnpm lint`)
- [ ] Application tested in browser/simulator
- [ ] No console errors during normal operation

---

### Summary: Frontend Development is User-Centric

> **Every frontend feature MUST prioritize user experience, accessibility, and security. Validation, loading states, error handling, and accessibility are NOT optional‚Äîthey are fundamental requirements for professional frontend development.**

**Critical Rules:**

1. **Always validate user inputs** - Client (debounced) + Server
2. **Always show loading states** - Users need feedback
3. **Always handle errors gracefully** - Clear, helpful messages
4. **Always ensure accessibility** - Keyboard navigation, ARIA labels
5. **Always use proper TypeScript types** - No `any`
6. **Always test in browser/simulator** - Don't assume it works
7. **Always sanitize user input** - Security is not optional

**Remember**: Frontend development is about creating excellent user experiences. Every decision should be made with the user in mind. üé®‚úÖ
