# iTrade Project - AI Agent Documentation Rules

## üìÇ Documentation Structure

When creating or modifying documentation files, follow this structure:

### Root Level

- `README.md` - Project overview and main documentation entry point
- Keep root directory clean, avoid creating new documentation files here

### Documentation Directories

#### `/docs/` - Project-level Documentation

Main documentation hub for the entire project.

**Subdirectories:**

- `/docs/guides/` - User guides and tutorials
  - Quick start guides
  - How-to guides
  - Best practices
  - Examples: `PROJECT_QUICK_START.md`, `RUN_COMMANDS.md`, `STRATEGY_MANAGEMENT_GUIDE.md`

- `/docs/development/` - Development process documentation
  - Implementation summaries
  - Improvement logs
  - Migration guides
  - Bug fixes documentation
  - Examples: `CONSOLE_WEB_IMPROVEMENTS.md`, `IMPLEMENTATION_SUMMARY.md`, `IMPROVEMENTS_SUMMARY.md`

- `/docs/api/` - API reference documentation
  - Existing: `API-REFERENCE-MARKET-DATA.md`
  - API specifications
  - Interface documentation

- `/docs/architecture/` - Architecture and design documentation
  - System design documents
  - Architecture decisions (ADR)
  - Technical specifications
  - Existing: `DESIGN-ANALYSIS-MARKET-DATA-API.md`, `trading-engine-analysis.md`

#### Application-Specific Documentation

**Console Application** - `/apps/console/docs/`

- `QUICK_START.md` - Console quick start guide
- Application-specific guides
- Console configuration

**Web Application** - `/apps/web/docs/`

- Web application guides
- API documentation
- Deployment guides

**Mobile Application** - `/apps/mobile/docs/`

- Mobile setup guides
- Platform-specific documentation
- Build instructions

#### Package-Specific Documentation

**Core Package** - `/packages/core/docs/`

- Core functionality documentation
- Examples: `ORDER_SYNC_MECHANISM.md`, `ORDER_SYNC_IMPLEMENTATION.md`
- API reference for core modules

**Data Manager** - `/packages/data-manager/docs/`

- Database schema documentation
- Data migration guides

**Exchange Connectors** - `/packages/exchange-connectors/docs/`

- Exchange integration guides
- Per-exchange documentation

**Other Packages** - `/packages/{package-name}/docs/`

- Package-specific documentation
- Usage examples
- API reference

---

## üìù Documentation Naming Conventions

### File Names

- Use `UPPERCASE_WITH_UNDERSCORES.md` for important top-level docs
- Use `lowercase-with-hyphens.md` for regular documentation
- Use descriptive names: `QUICK_START.md`, `API_REFERENCE.md`

### Bilingual Documentation Naming

**Default Language**: English (no suffix)
**Chinese Version**: Add `_CN` suffix

Examples:

- `README.md` - English (default)
- `README_CN.md` - Chinese version
- `QUICK_START.md` - English
- `QUICK_START_CN.md` - Chinese version
- `API_REFERENCE.md` - English
- `API_REFERENCE_CN.md` - Chinese version

**Rationale**:

- English is the international standard for open-source projects
- Cursor AI and most development tools work best with English
- Makes the project more accessible to global developers

### Document Types and Locations

| Document Type | Location | Example |
|--------------|----------|---------|
| Quick Start Guide | `{app}/docs/QUICK_START.md` | `apps/console/docs/QUICK_START.md` |
| User Guide | `docs/guides/` | `docs/guides/STRATEGY_MANAGEMENT_GUIDE.md` |
| API Reference | `docs/api/` or `{package}/docs/` | `packages/core/docs/API_REFERENCE.md` |
| Implementation Log | `docs/development/` | `docs/development/IMPLEMENTATION_SUMMARY.md` |
| Architecture Doc | `docs/architecture/` | `docs/architecture/SYSTEM_DESIGN.md` |
| Package Feature Doc | `{package}/docs/` | `packages/core/docs/ORDER_SYNC_MECHANISM.md` |
| Troubleshooting | `docs/guides/` | `docs/guides/TROUBLESHOOTING.md` |
| Changelog | `docs/development/` | `docs/development/CHANGELOG.md` |

---

## üéØ When Creating New Documentation

### Step 1: Determine Document Type

Ask yourself:

- Is this a user guide? ‚Üí `docs/guides/`
- Is this implementation/improvement documentation? ‚Üí `docs/development/`
- Is this API reference? ‚Üí `docs/api/` or `{package}/docs/`
- Is this architecture/design? ‚Üí `docs/architecture/`
- Is this specific to an application? ‚Üí `apps/{app}/docs/`
- Is this specific to a package feature? ‚Üí `packages/{package}/docs/`

### Step 2: Choose Appropriate Location

```
# For a new core package feature
‚úÖ packages/core/docs/NEW_FEATURE.md
‚ùå /NEW_FEATURE.md (root directory)

# For console application guide
‚úÖ apps/console/docs/USAGE_GUIDE.md
‚ùå /CONSOLE_USAGE_GUIDE.md (root directory)

# For project-wide implementation summary
‚úÖ docs/development/FEATURE_IMPLEMENTATION.md
‚ùå /IMPLEMENTATION.md (root directory)

# For user guide or tutorial
‚úÖ docs/guides/HOW_TO_DEPLOY.md
‚ùå /DEPLOYMENT.md (root directory)
```

### Step 3: Link from README

Update the relevant README.md to reference your new documentation:

- Main `README.md` for project-level docs
- Package `README.md` for package-specific docs
- Application `README.md` for app-specific docs

---

## üìö Documentation Templates

### Quick Start Template

```markdown
# {Application/Package} Quick Start Guide

## Prerequisites
- List requirements

## Installation
- Step by step

## Usage
- Basic usage examples

## Next Steps
- Links to detailed guides
```

### Implementation/Feature Template

```markdown
# {Feature Name} Implementation

## Overview
Brief description

## Implementation Details
Technical details

## Usage
How to use

## Testing
How to test

## Related Documentation
Links to related docs
```

---

## üîÑ Migration Rules

When AI generates documentation in the root directory:

1. **Immediately recognize** the document type
2. **Move to appropriate location**:

   ```bash
   # Example
   mv ROOT_DOC.md docs/guides/ROOT_DOC.md
   # or
   mv FEATURE_DOC.md packages/core/docs/FEATURE_DOC.md
   ```

3. **Update any references** in other files
4. **Add to relevant README** for discoverability

---

## ‚úÖ Best Practices

1. **Keep root clean**: Only `README.md` and essential project files
2. **Use subdirectories**: Organize by type and scope
3. **Link documents**: Cross-reference related documentation
4. **Update READMEs**: Keep README files up-to-date with doc links
5. **Consistent naming**: Follow naming conventions
6. **Clear hierarchy**: User docs separate from dev docs

---

## üé® Document Structure

### Every Document Should Have

1. **Title** (H1)
2. **Brief description** (1-2 sentences)
3. **Table of contents** (for long docs)
4. **Main content** (well-structured with headings)
5. **Related links** (at the end)
6. **Last updated date** (optional but recommended)

---

## üìñ Examples of Well-Organized Documentation

### Good Examples ‚úÖ

```
packages/core/docs/
‚îú‚îÄ‚îÄ README.md (package overview + links to all docs)
‚îú‚îÄ‚îÄ ORDER_SYNC_MECHANISM.md (feature design)
‚îú‚îÄ‚îÄ ORDER_SYNC_IMPLEMENTATION.md (implementation)
‚îî‚îÄ‚îÄ API_REFERENCE.md (API docs)

apps/console/docs/
‚îú‚îÄ‚îÄ QUICK_START.md (how to start)
‚îú‚îÄ‚îÄ CONFIGURATION.md (config guide)
‚îî‚îÄ‚îÄ DEPLOYMENT.md (deployment guide)

docs/
‚îú‚îÄ‚îÄ guides/
‚îÇ   ‚îú‚îÄ‚îÄ PROJECT_QUICK_START.md
‚îÇ   ‚îî‚îÄ‚îÄ STRATEGY_MANAGEMENT_GUIDE.md
‚îú‚îÄ‚îÄ development/
‚îÇ   ‚îú‚îÄ‚îÄ IMPLEMENTATION_SUMMARY.md
‚îÇ   ‚îî‚îÄ‚îÄ CONSOLE_WEB_IMPROVEMENTS.md
‚îî‚îÄ‚îÄ architecture/
    ‚îî‚îÄ‚îÄ SYSTEM_DESIGN.md
```

### Bad Examples ‚ùå

```
# Don't do this:
‚îú‚îÄ‚îÄ QUICK_START.md (which app?)
‚îú‚îÄ‚îÄ FEATURE_1.md (unclear purpose)
‚îú‚îÄ‚îÄ NEW_IMPLEMENTATION.md (what implementation?)
‚îú‚îÄ‚îÄ DOCS.md (too vague)
‚îî‚îÄ‚îÄ NOTES.md (should be in proper location)
```

---

## ü§ñ AI Agent Instructions

When you (AI) create documentation:

1. **NEVER put files in root directory** (except README.md updates)
2. **ASK** if unclear where to place: "This looks like a {type} document. Should I place it in {location}?"
3. **SUGGEST** appropriate location based on content
4. **CREATE** directory structure if it doesn't exist
5. **UPDATE** relevant README files with links
6. **FOLLOW** naming conventions consistently
7. **DO NOT create summary documents** after completing tasks unless explicitly requested by the user

### Decision Tree for AI

```
Is it a Quick Start?
‚îî‚îÄ Yes ‚Üí apps/{app}/docs/QUICK_START.md
‚îî‚îÄ No ‚Üì

Is it implementation/improvement documentation?
‚îî‚îÄ Yes ‚Üí docs/development/{NAME}.md
‚îî‚îÄ No ‚Üì

Is it a package feature documentation?
‚îî‚îÄ Yes ‚Üí packages/{package}/docs/{FEATURE}.md
‚îî‚îÄ No ‚Üì

Is it a user guide?
‚îî‚îÄ Yes ‚Üí docs/guides/{NAME}.md
‚îî‚îÄ No ‚Üì

Is it architecture/design?
‚îî‚îÄ Yes ‚Üí docs/architecture/{NAME}.md
‚îî‚îÄ No ‚Üì

Is it API reference?
‚îî‚îÄ Yes ‚Üí docs/api/{NAME}.md or packages/{package}/docs/API.md
```

---

## üìå Summary

**Golden Rule**: Documentation should be close to what it documents.

- **Application docs** ‚Üí `apps/{app}/docs/`
- **Package docs** ‚Üí `packages/{package}/docs/`
- **Project docs** ‚Üí `docs/{category}/`
- **Root directory** ‚Üí Keep clean!

When in doubt, put it in `docs/guides/` and organize later.

**Remember**: Good documentation structure makes the project more maintainable and user-friendly! üìö‚ú®

---

## ‚úçÔ∏è Documentation Signature Rules

### Required Ending Signature

**All documentation, posts, and technical articles MUST end with the following signature format:**

```markdown
---

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

### Examples

#### For Documentation Files

```markdown
---

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

#### For Wiki Posts

```markdown
---

*This article is written based on actual development experience of the iTrade project.*

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

#### For Implementation Summaries

```markdown
---

*Implementation completed and verified through automated testing.*

Author: xiaoweihsueh@gmail.com  
Date: [Current Date in format: Month Day, Year]
```

### AI Agent Instructions for Signatures

1. **ALWAYS include** the signature at the end of every document
2. **Use the actual current date when you are writing** (e.g., if today is December 10, 2024, use "December 10, 2024")
3. **Do NOT use placeholder text** - always replace with the real current date
4. **Do NOT include version numbers** - only Author and Date
5. **Maintain consistent formatting** with the examples above
6. **Add contextual notes** above the signature when appropriate (e.g., project context, implementation status)

**Critical**:

- When you see `[Current Date in format: Month Day, Year]` in the template, replace it with TODAY'S actual date
- Format: "Month Day, Year" (e.g., "December 10, 2024")
- Use the date when you are actually creating/updating the document, not a fixed date

### Signature Placement

- Place signature **after main content** but **before references/links section**
- Use `---` horizontal rule to separate signature from main content
- Keep signature formatting consistent across all documents

This ensures consistent authorship attribution and helps track document creation/modification dates across the entire project.

---

## üîß Code Quality and Linting Rules

### Mandatory Post-Edit Linting

**After ANY modification to source code or documentation files, AI agents MUST execute appropriate linting commands to ensure code quality and formatting compliance.**

#### Critical Rules Summary

> **üö® MANDATORY: Run `pnpm lint --fix` after EVERY source code modification**
>
> This single command:
>
>
> 1. ‚úÖ Checks TypeScript/JavaScript errors (ESLint)
> 2. ‚úÖ Applies Prettier formatting automatically
> 3. ‚úÖ Fixes import ordering
> 4. ‚úÖ Removes unused imports
> 5. ‚úÖ Ensures consistent code style
>
> **NEVER skip this step. NEVER leave formatting/linting errors.**

#### Required Actions After Code Changes

1. **For TypeScript/JavaScript files** (`.ts`, `.tsx`, `.js`, `.jsx`):

   ```bash
   # Run lint check for the specific project
   pnpm lint                    # For Next.js apps
   npm run lint                 # For other packages
   
   # If linting errors are found, attempt to auto-fix
   pnpm lint --fix             # Auto-fix when possible
   ```

2. **For Markdown files** (`.md`):

   ```bash
   # Check markdown formatting
   pnpm lint                   # If project has markdown linting
   # Or use dedicated markdown linter if available
   ```

3. **For JSON/Config files** (`.json`, `.yaml`, `.yml`):

   ```bash
   # Validate JSON/YAML syntax
   pnpm lint                   # Project-specific linting
   ```

#### Workflow Requirements

1. **ALWAYS run linting** after making code changes
2. **REPORT linting results** to the user
3. **ATTEMPT to fix** common formatting issues automatically
4. **STOP and ask for guidance** if critical errors cannot be auto-fixed
5. **NEVER leave broken code** - ensure all changes compile and pass basic checks

#### Project-Specific Lint Commands

| Project Location | Command | Description |
|------------------|---------|-------------|
| `/apps/web/` | `pnpm lint` | Next.js web application linting |
| `/apps/console/` | `pnpm lint` | Node.js console application linting |
| `/apps/mobile/` | `flutter analyze` | Flutter mobile app analysis |
| `/packages/*/` | `pnpm lint` or `npm run lint` | Package-specific linting |
| Root directory | `pnpm lint:all` | Lint all workspaces (if available) |

#### Error Handling Protocol

```markdown
1. Run appropriate lint command
2. If errors found:
   - Try auto-fix: `pnpm lint --fix`
   - Report remaining errors to user
   - Provide specific line numbers and descriptions
   - Suggest manual fixes if auto-fix failed
3. If critical errors:
   - Do not proceed with additional changes
   - Ask user for guidance on error resolution
4. If warnings only:
   - Report warnings but may proceed
   - Suggest improvements for code quality
```

#### AI Agent Instructions for Linting

1. **EXECUTE linting immediately** after any file modification
2. **ALWAYS run `pnpm lint --fix`** to auto-fix ESLint + Prettier issues
3. **USE the read_lints tool** to check for specific file linting errors
4. **BATCH lint checks** when modifying multiple files in the same project
5. **PRIORITIZE auto-fixable issues** over manual interventions
6. **VERIFY formatting** matches Prettier configuration
7. **DOCUMENT any persistent errors** that require manual attention

**Formatting-Specific Instructions:**

- ‚úÖ Write code with single quotes from the start
- ‚úÖ Add semicolons to all statements
- ‚úÖ Use 2-space indentation
- ‚úÖ Keep lines under 100 characters when practical
- ‚úÖ Run `pnpm lint --fix` immediately after modifications
- ‚úÖ Never complete a task with Prettier errors

#### Example Workflow

```bash
# After modifying apps/web/components/example.tsx
cd apps/web
pnpm lint

# If errors found
pnpm lint --fix

# Check specific file if needed
pnpm lint --file components/example.tsx
```

#### Quality Gates

- **No compilation errors** allowed
- **Critical linting errors** must be resolved
- **Warnings should be minimized** where possible
- **Consistent formatting** across all files
- **Import organization** following project standards

#### Skip Conditions

Linting may be skipped ONLY when:

- User explicitly requests to skip linting
- Working on draft/experimental code that user acknowledges is temporary
- System/configuration files that don't support linting

**Default behavior: ALWAYS run linting unless explicitly told otherwise.**

---

## üé® Code Formatting Rules (Prettier)

### Mandatory Prettier Formatting

**ALL source code modifications MUST follow the Prettier configuration defined in the project. AI agents MUST ensure code is properly formatted before committing changes.**

#### Core Principle

> **"Write code that matches the existing codebase style automatically"**
>
>
> When adding or modifying source code, AI agents MUST:
>
> 1. **Follow Prettier configuration** automatically
> 2. **Run `pnpm lint --fix`** to apply formatting
> 3. **NEVER leave formatting errors** in the code

#### Prettier Configuration Location

- **Root Configuration**: `.prettierrc`, `.prettierrc.json`, or `prettier.config.js`
- **Editor Config**: `.editorconfig` (if present)
- **Package-specific**: May override in package directories

#### Key Formatting Rules (Enforced by Prettier)

Based on the project's Prettier configuration:

| Rule | Setting | Example |
|------|---------|---------|
| **Quote Style** | Single quotes (`'`) | `import { foo } from 'bar';` |
| **Semicolons** | Required (`;`) | `const x = 1;` |
| **Trailing Commas** | ES5 style | `{ a, b, c }` not `{ a, b, c, }` |
| **Line Width** | 80-100 characters | Auto-wrap long lines |
| **Indentation** | 2 spaces | Consistent spacing |
| **Arrow Functions** | Parentheses when needed | `(x) => x + 1` |

#### Automatic Formatting Workflow

**Standard Process:**

```bash
# Step 1: Modify code files
# (AI agent makes changes)

# Step 2: Run linting with auto-fix (includes Prettier)
cd <project-directory>
pnpm lint --fix

# Step 3: Verify no formatting errors remain
pnpm lint

# Step 4: If errors persist, read and fix manually
# (Then rerun Step 2-3)
```

#### Common Prettier Fixes

**1. Quote Style**

```typescript
// ‚ùå BAD (double quotes)
import { Component } from "react"

// ‚úÖ GOOD (single quotes)

import { Component } from 'react';
```

**2. Semicolons**

```typescript
// ‚ùå BAD (missing semicolons)
const x = 1
const y = 2

// ‚úÖ GOOD (with semicolons)

const x = 1;
const y = 2;
```

**3. Long Lines**

```typescript
// ‚ùå BAD (exceeds line width)
const result = someVeryLongFunctionName(param1, param2, param3, param4, param5, param6);

// ‚úÖ GOOD (auto-wrapped)
const result = someVeryLongFunctionName(
  param1,
  param2,
  param3,
  param4,

  param5,
  param6
);
```

**4. Object/Array Formatting**

```typescript
// ‚ùå BAD (inconsistent formatting)
const obj = {a:1,b:2,c:3}

// ‚úÖ GOOD (Prettier formatted)
const obj = { a: 1, b: 2, c: 3 };

// For long objects:
const obj = {

  property1: 'value1',
  property2: 'value2',
  property3: 'value3',
};
```

**5. Import Statements**

```typescript
// ‚ùå BAD (wrong quote style)
import {foo,bar,baz} from "module"

// ‚úÖ GOOD (Prettier formatted)
import { foo, bar, baz } from 'module';
```

#### AI Agent Formatting Protocol

**When writing new code:**

1. ‚úÖ **Write code following Prettier rules from the start**
2. ‚úÖ **Use single quotes** for strings
3. ‚úÖ **Add semicolons** at statement ends
4. ‚úÖ **Keep lines under 100 characters** when possible
5. ‚úÖ **Use consistent spacing** (2 spaces indentation)
6. ‚úÖ **Format imports** properly (single quotes, proper spacing)

**After code modification:**

1. ‚úÖ **ALWAYS run `pnpm lint --fix`** immediately
2. ‚úÖ **Verify formatting** with `pnpm lint`
3. ‚úÖ **Fix any remaining issues** before proceeding
4. ‚úÖ **Report formatting status** to user

**CRITICAL RULE:**

> **NEVER commit or complete a task with Prettier formatting errors. If `pnpm lint --fix` doesn't resolve all issues, manually fix them before proceeding.**

#### Project-Specific Prettier Commands

| Location | Command | Purpose |
|----------|---------|---------|

| `/apps/web/` | `pnpm lint --fix` | Format web app code |
| `/apps/console/` | `pnpm lint --fix` | Format console app code |
| `/packages/*/` | `pnpm lint --fix` | Format package code |
| Root | `pnpm lint:all --fix` | Format entire monorepo |

#### Prettier Integration with Tools

**ESLint Integration:**

- Prettier runs as part of ESLint (`eslint-plugin-prettier`)
- `pnpm lint --fix` applies both ESLint and Prettier fixes
- Conflicts are resolved in favor of Prettier

**Editor Integration:**

- VS Code: Uses workspace Prettier config
- Format on save: Recommended for developers
- AI agents: Must use CLI commands

#### Error Detection and Resolution

**Common Prettier Errors:**

```bash
# Error Example:
./components/example.tsx
12:45  Error: Replace `"react"` with `'react';`  prettier/prettier
15:1   Error: Delete `¬∑¬∑`  prettier/prettier
20:80  Error: Insert `‚èé¬∑¬∑`  prettier/prettier
```

**Resolution Steps:**

1. Run `pnpm lint --fix` (auto-fixes most issues)
2. If errors remain, manually review:
   - Check quote style
   - Verify semicolons
   - Check line length
   - Verify indentation
3. Re-run `pnpm lint --fix`
4. Verify with `pnpm lint`

#### Quality Gates for Formatting

**MUST PASS before task completion:**

- ‚úÖ No Prettier errors in `pnpm lint` output
- ‚úÖ All quotes are single quotes (`'`)
- ‚úÖ All statements end with semicolons (`;`)
- ‚úÖ Indentation is consistent (2 spaces)
- ‚úÖ Line length is reasonable (<100 chars)
- ‚úÖ Imports are properly formatted

#### Skip Conditions

Prettier formatting may be skipped ONLY when:

- User explicitly requests to skip formatting
- Working with auto-generated code that will be regenerated
- Editing non-source files (`.md`, `.txt`, etc.) without Prettier config

**Default behavior: ALWAYS apply Prettier formatting to source code.**

---

## üì¶ Package Build Rules

### Mandatory Package Rebuild

**After ANY modification to source files under `packages/**`, AI agents MUST:**

1. ‚úÖ **Rebuild the modified package** - Compile TypeScript changes
2. ‚úÖ **Rebuild dependent packages** (if any) - Ensure type propagation
3. ‚úÖ **Rebuild web application** - **MANDATORY** final verification step

**This ensures changes are compiled, types are updated, and everything integrates correctly.**

#### When to Rebuild

Rebuild is REQUIRED when modifying:

1. **TypeScript/JavaScript source files** (`packages/*/src/**/*.ts`, `*.tsx`, `*.js`, `*.jsx`)
2. **Entity definitions** (`packages/data-manager/src/entities/**/*.ts`)
3. **Type definitions** (`packages/*/src/types/**/*.ts`)
4. **Repository files** (`packages/data-manager/src/repositories/**/*.ts`)
5. **Any exported modules** that other packages depend on

#### Package Dependencies

```
Common dependency chains:
- data-manager ‚Üí core, strategies, exchange-connectors
- core ‚Üí strategies, exchange-connectors
- utils ‚Üí all packages
- logger ‚Üí all packages
```

#### Rebuild Commands

| Package | Command | Build Time |
|---------|---------|------------|
| `packages/core` | `cd packages/core && pnpm build` | ~2-5s |

| `packages/data-manager` | `cd packages/data-manager && pnpm build` | ~3-8s |
| `packages/strategies` | `cd packages/strategies && pnpm build` | ~2-4s |
| `packages/utils` | `cd packages/utils && pnpm build` | ~1-2s |
| `packages/logger` | `cd packages/logger && pnpm build` | ~1-2s |
| `packages/exchange-connectors` | `cd packages/exchange-connectors && pnpm build` | ~2-4s |

| All packages | `pnpm build --filter "./packages/*"` | ~10-20s |

#### Rebuild Workflow

1. **Identify modified package**:

   ```bash
   # Example: Modified packages/data-manager/src/entities/Strategy.ts
   ```

2. **Rebuild the package**:

   ```bash
   cd packages/data-manager && pnpm build
   ```

3. **Rebuild dependent packages** (if needed):

   ```bash
   # If core depends on data-manager and was using the modified code
   cd packages/core && pnpm build
   ```

4. **Rebuild web application to verify**:

   ```bash
   # ALWAYS rebuild web to ensure everything works
   cd apps/web && pnpm build
   ```

5. **Verify build success**:

   ```bash
   # Check for build errors
   # Ensure no TypeScript compilation errors
   # Confirm web build completes successfully
   ```

#### AI Agent Instructions for Package Builds

1. **ALWAYS rebuild** after modifying package source files
2. **Build in dependency order** (dependencies first, then dependents)
3. **ALWAYS rebuild web application** after package changes to verify integration
4. **Report build status** to the user at each step
5. **If build fails**:
   - Report the exact error
   - Attempt to fix the issue
   - Rebuild after fixing
6. **Batch builds** when modifying multiple packages
7. **Never skip web build** - it's the final verification step

#### Example Workflow

```bash
# Scenario: Modified Strategy entity and StrategyRepository

# Step 1: Identify modified package
echo "Modified: packages/data-manager/src/entities/Strategy.ts"
echo "Modified: packages/data-manager/src/repositories/StrategyRepository.ts"

# Step 2: Rebuild data-manager
cd packages/data-manager
pnpm build

# Step 3: Rebuild dependent packages if needed
# If core/strategies import from data-manager, rebuild them too
cd ../core
pnpm build

# Step 4: ALWAYS rebuild web to verify everything works
cd ../../apps/web
pnpm build

# Step 5: Verify no errors
echo "‚úÖ All packages rebuilt successfully"
echo "‚úÖ Web application build verified"
```

#### Build Optimization

- **Incremental builds**: TypeScript only rebuilds changed files
- **Parallel builds**: Use `pnpm -r --parallel build` for multiple packages
- **Skip if no TypeScript changes**: Don't rebuild for doc-only changes

#### Skip Conditions

Rebuild may be skipped ONLY when:

- Only modifying `.md` documentation files
- Only modifying test files (`*.test.ts`, `*.spec.ts`) in non-published packages
- Only modifying configuration files (`.json`, `.yml`) that don't affect build output
- User explicitly requests to skip rebuild (rare)

#### Common Build Errors and Solutions

| Error | Cause | Solution |
|-------|-------|----------|
| `Cannot find module` | Package not rebuilt | Rebuild the dependency |
| `Type error` | Outdated type definitions | Rebuild packages in order |
| `Circular dependency` | Import cycle | Check and fix imports |
| `Out of memory` | Large build | Increase Node memory |

#### Performance Considerations

- Average single package build: **2-5 seconds**
- Average multi-package build: **10-20 seconds**
- Full monorepo build: **30-60 seconds**
- **Web application build: 3-5 seconds**

**Total time for typical workflow:**

- Single package + web: **5-10 seconds**
- Multiple packages + web: **15-25 seconds**
- Full rebuild + web: **35-65 seconds**

**Always rebuild to avoid runtime errors and type mismatches!**

### Quick Reference

```bash
# Standard workflow (RECOMMENDED)
# 1. Rebuild modified package
cd packages/{package-name} && pnpm build

# 2. Rebuild dependent packages (if any)
cd ../dependent-package && pnpm build

# 3. ALWAYS rebuild web to verify
cd ../../apps/web && pnpm build

# ---

# Alternative: Multiple packages (if interdependent)
cd packages/data-manager && pnpm build && \
cd ../core && pnpm build && \
cd ../strategies && pnpm build && \
cd ../../apps/web && pnpm build

# Alternative: All packages + web at once
pnpm build --filter "./packages/*" && \
cd apps/web && pnpm build

# Alternative: Parallel (faster but harder to debug)
pnpm -r --parallel --filter "./packages/*" build && \
cd apps/web && pnpm build
```

**Critical Rule**: ALWAYS finish with `cd apps/web && pnpm build` to verify integration! üèóÔ∏è‚úÖ
